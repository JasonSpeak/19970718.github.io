<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计网相关问题</title>
      <link href="/2020/04/03/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
      <url>/2020/04/03/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h4 id="计算机网络相关常见问题"><a href="#计算机网络相关常见问题" class="headerlink" title="计算机网络相关常见问题"></a>计算机网络相关常见问题</h4><h5 id="3次握手和4次挥手"><a href="#3次握手和4次挥手" class="headerlink" title="3次握手和4次挥手"></a>3次握手和4次挥手</h5><ul><li>TCP使用3次握手建立一条连接，该握手初始化了传输可靠性以及数据顺序性必要的信息，这些信息包括两个方向的初始序列号，确认号由初始序列号生成，使用3次握手是因为3次握手已经准备好了传输可靠性以及数据顺序性所必要的信息，该握手的第3次实际上并不是需要单独传输的，完全可以和数据一起传输。</li><li>TCP使用4次挥手拆除一条连接，为何需要4次呢？因为TCP是一个全双工协议，必须单独拆除每一条信道。注意，4次挥手和3次握手的意义是不同的，很多人都会问为何建立连接是3次握手，而拆除连接是4次挥手。</li><li>3次握手的目的很简单，就是分配资源，初始化序列号，这时还不涉及数据传输，3次就足够做到这个了，而4次挥手的目的是终止数据传输，并回收资源，此时两个端点两个方向的序列号已经没有了任何关系，必须等待两方向都没有数据传输时才能拆除虚链路，不像初始化时那么简单，发现SYN标志就初始化一个序列号并确认SYN的序列号。因此必须单独分别在一个方向上终止该方向的数据传输。</li></ul><h5 id="传输可靠性"><a href="#传输可靠性" class="headerlink" title="传输可靠性"></a>传输可靠性</h5><ul><li>基本上传输可靠性是靠确认号实现的，也就是说，每发送一个分段，接下来接收端必然要发送一个确认，发送端收到确认后才可以发送下一个字节。这个原则最简单不过了，教科书上的“停止-等待”协议就是这个原则的字节版本，只是TCP使用了滑动窗口机制使得每次不一定发送一个字节，但是这是后话，本节仅仅谈一下确认的超时机制。</li><li>怎么知道数据到达对端呢？那就是对端发送一个确认，但是如果一直收不到对端的确认，发送端等多久呢？如果一直等下去，那么将无法发现数据的丢失，协议将不可用，如果等待时间过短，可能确认还在路上，因此等待时间是个问题，另外如何去管理这个超时时间也是一个问题。</li></ul><h5 id="TIME-WAIT状态"><a href="#TIME-WAIT状态" class="headerlink" title="TIME_WAIT状态"></a>TIME_WAIT状态</h5><ul><li>为何要有这个状态，原因很简单，那就是每次建立连接的时候序列号都是随机产生的，并且这个序列号是32位的，会回绕。现在我来解释这和TIME_WAIT有什么关系。任何的TCP分段都要在尽力而为的IP网络上传输，中间的路由器可能会随意的缓存任何的IP数据报，它并不管这个IP数据报上被承载的是什么数据，然而根据经验和互联网的大小，一个IP数据报最多存活MSL(这是根据地球表面积，电磁波在各种介质中的传输速率以及IP协议的TTL等综合推算出来的，如果在火星上，这个MSL会大得多…)。</li><li>现在我们考虑终止连接时的被动方发送了一个FIN，然后主动方回复了一个ACK，然而这个ACK可能会丢失，这会造成被动方重发FIN，这个FIN可能会在互联网上存活MSL。</li><li>如果没有TIME_WAIT的话，假设连接1已经断开，然而其被动方最后重发的那个FIN(或者FIN之前发送的任何TCP分段)还在网络上，然而连接2重用了连接1的所有的5元素(源IP，目的IP，TCP，源端口，目的端口)，刚刚将建立好连接，连接1迟到的FIN到达了，这个FIN将以比较低但是确实可能的概率终止掉连接2。为何说是概率比较低呢？这涉及到一个匹配问题，迟到的FIN分段的序列号必须落在连接2的一方的期望序列号范围之内。虽然这种巧合很少发生，但确实会发生，毕竟初始序列号是随机产生了。因此终止连接的主动方必须在接受了被动方且回复了ACK之后等待2*MSL时间才能进入CLOSE状态，之所以乘以2是因为这是保守的算法，最坏情况下，针对被动方的ACK在以最长路线(经历一个MSL)经过互联网马上到达被动方时丢失。</li><li>为了应对这个问题，RFC793对初始序列号的生成有个建议，那就是设定一个基准，在这个基准之上搞随机，这个基准就是时间，我们知道时间是单调递增的。然而这仍然有问题，那就是回绕问题，如果发生回绕，那么新的序列号将会落到一个很低的值。因此最好的办法就是避开“重叠”，其含义就是基准之上的随机要设定一个范围。</li><li>很多人很不喜欢看到服务器上出现大量的TIME_WAIT状态的连接，因此他们将TIME_WAIT的值设置的很低，这虽然在大多数情况下可行，然而确实也是一种冒险行为。最好的方式就是，不要重用一个连接。</li></ul><h5 id="重用一个连接和重用一个套接字"><a href="#重用一个连接和重用一个套接字" class="headerlink" title="重用一个连接和重用一个套接字"></a>重用一个连接和重用一个套接字</h5><ul><li>这是根本不同的，单独重用一个套接字一般不会有任何问题，因为TCP是基于连接的。比如在服务器端出现了一个TIME_WAIT连接，那么该连接标识了一个五元素，只要客户端不使用相同的源端口，连接服务器是没有问题的，因为迟到的FIN永远不会到达这个连接。记住，一个五元素标识了一个连接，而不是一个套接字(当然，对于BSD套接字而言，服务端的accept套接字确实标识了一个连接)。</li></ul><h5 id="超时时间的计算"><a href="#超时时间的计算" class="headerlink" title="超时时间的计算"></a>超时时间的计算</h5><ul><li>绝对不能随意去揣测超时的时间，而应该给出一个精确的算法去计算。毫无疑问，一个TCP分段的回复到达的时间就是一个数据报往返的时间，因此标准定义了一个新的名词RTT，代表一个TCP分段的往返时间。然而我们知道，IP网络是尽力而为的，并且路由是动态的，且路由器会毫无先兆的缓存或者丢弃任何的数据报，因此这个RTT是需要动态测量的，也就是说起码每隔一段时间就要测量一次，如果每次都一样，万事大吉，然而世界并非如你所愿，因此我们需要找到的恰恰的一个“平均值”，而不是一个准确值。   </li><li>这个平均值如果仅仅直接通过计算多次测量值取算术平均，那是不恰当的，因为对于数据传输延时，我们必须考虑的路径延迟的瞬间抖动，否则如果两次测量值分别为2和98，那么超时值将是50，这个值对于2而言，太大了，结果造成了数据的延迟过大(本该重传的等待了好久才重传)，然而对于98而言，太小了，结果造成了过度重传(路途遥远，本该很慢，结果大量重传已经正确确认但是迟到的TCP分段)。</li><li>因此，除了考虑每两次测量值的偏差之外，其变化率也应该考虑在内，如果变化率过大，则通过以变化率为自变量的函数为主计算RTT(如果陡然增大，则取值为比较大的正数，如果陡然减小，则取值为比较小的负数，然后和平均值加权求和)，反之如果变化率很小，则取测量平均值。这是不言而喻的，这个算法至今仍然工作的很好。</li></ul><h5 id="超时计时器的管理-每连接单一计时器"><a href="#超时计时器的管理-每连接单一计时器" class="headerlink" title="超时计时器的管理-每连接单一计时器"></a>超时计时器的管理-每连接单一计时器</h5><ul><li>很显然，对每一个TCP分段都生成一个计时器是最直接的方式，每个计时器在RTT时间后到期，如果没有收到确认，则重传。然而这只是理论上的合理，对于大多数操作系统而言，这将带来巨大的内存开销和调度开销，因此采取每一个TCP连接单一计时器的设计则成了一个默认的选择。可是单一的计时器怎么管理如此多的发出去的TCP分段呢？又该如何来设计单一的计时器呢。</li><li>设计单一计时器有两个原则：1.每一个报文在长期收不到确认都必须可以超时；2.这个长期收不到中长期不能和测量的RTT相隔太远。因此RFC2988定义一套很简单的原则：<ul><li>a.发送TCP分段时，如果还没有重传定时器开启，那么开启它。</li><li>b.发送TCP分段时，如果已经有重传定时器开启，不再开启它。</li><li>c.收到一个非冗余ACK时，如果有数据在传输中，重新开启重传定时器。</li><li>d.收到一个非冗余ACK时，如果没有数据在传输中，则关闭重传定时器。</li></ul></li><li>我们看看这4条规则是如何做到以上两点的，根据a和c(在c中，注意到ACK是非冗余的)，任何TCP分段只要不被确认，超时定时器总会超时的。然而为何需要c呢？只有规则a存在的话，也可以做到原则1。实际上确实是这样的，但是为了不会出现过早重传，才添加了规则c，如果没有规则c，那么万一在重传定时器到期前，发送了一些数据，这样在定时器到期后，除了很早发送的数据能收到ACK外，其它稍晚些发送的数据的ACK都将不会到来，因此这些数据都将被重传。有了规则c之后，只要有分段ACK到来，则重置重传定时器，这很合理，因此大多数正常情况下，从数据的发出到ACK的到来这段时间以及计算得到的RTT以及重传定时器超时的时间这三者相差并不大，一个ACK到来后重置定时器可以保护后发的数据不被过早重传。</li><li>这里面还有一些细节需要说明。一个ACK到来了，说明后续的ACK很可能会依次到来，也就是说丢失的可能性并不大，另外，即使真的有后发的TCP分段丢失现象发生，也会在最多2倍定时器超时时间的范围内被重传(假设该报文是第一个报文发出启动定时器之后马上发出的，丢失了，第一个报文的ACK到来后又重启了定时器，又经过了一个超时时间才会被重传)。虽然这里还没有涉及拥塞控制，但是可见网络拥塞会引起丢包，丢包会引起重传，过度重传反过来加重网络拥塞，设置规则c的结果可以缓解过多的重传，毕竟将启动定时器之后发送的数据的重传超时时间拉长了最多一倍左右。最多一倍左右的超时偏差做到了原则2，即“这个长期收不到中长期不能和测量的RTT相隔太远”。</li><li>还有一点，如果是一个发送序列的最后一个分段丢失了，后面就不会收到冗余ACK，这样就只能等到超时了，并且超时时间几乎是肯定会比定时器超时时间更长。如果这个分段 是在发送序列的靠后的时间发送的且和前面的发送时间相隔时间较远，则其超时时间不会很大，反之就会比较大。</li></ul><h5 id="何时测量RTT"><a href="#何时测量RTT" class="headerlink" title="何时测量RTT"></a>何时测量RTT</h5><ul><li>目前很多TCP实现了时间戳，这样就方便多了，发送端再也不需要保存发送分段的时间了，只需要将其放入协议头的时间戳字段，然后接收端将其回显在ACK即可，然后发送端收到ACK后，取出时间戳，和当前时间做算术差，即可完成一次RTT的测量。</li></ul><h5 id="确认号和超时重传"><a href="#确认号和超时重传" class="headerlink" title="确认号和超时重传"></a>确认号和超时重传</h5><ul><li>确认号是一个很诡异的东西，因为TCP的发送端对于发送出去的一个数据序列，它只要收到一个确认号就认为确认号前面的数据都被收到了，即使前面的某个确认号丢失了，也就是说，发送端只认最后一个确认号。这是合理的，因为确认号是接收端发出的，接收端只确认按序到达的最后一个TCP分段。</li><li>另外，发送端重发了一个TCP报文并且接收到该TCP分段的确认号，并不能说明这个重发的报文被接收了，也可能是数据早就被接收了，只是由于其ACK丢失或者其ACK延迟到达导致了超时。值得说明的是，接收端会丢弃任何重复的数据，即使丢弃了重复的数据，其ACK还是会照发不误的。</li><li>标准的早期TCP实现为，只要一个TCP分段丢失，即使后面的TCP分段都被完整收到，发送端还是会重传从丢失分段开始的所有报文，这就会导致一个问题，那就是重传风暴，一个分段丢失，引起大量的重传。这种风暴实则不必要的，因为大多数的TCP实现中，接收端已经缓存了乱序的分段，这些被重传的丢失分段之后的分段到达接收端之后，很大的可能性是被丢弃。关于这一点在拥塞控制被引入之后还会提及(问题先述为快：本来报文丢失导致超时就说明网络很可能已然拥塞，重传风暴只能加重其拥塞程度)。</li></ul><h5 id="乱序数据缓存以及选择确认"><a href="#乱序数据缓存以及选择确认" class="headerlink" title="乱序数据缓存以及选择确认"></a>乱序数据缓存以及选择确认</h5><ul><li>TCP是保证数据顺序的，但是并不意味着它总是会丢弃乱序的TCP分段，具体会不会丢弃是和具体实现相关的，RFC建议如果内存允许，还是要缓存这些乱序到来的分段，然后实现一种机制等到可以拼接成一个按序序列的时候将缓存的分段拼接，这就类似于IP协议中的分片一样，但是由于IP数据报是不确认的，因此IP协议的实现必须缓存收到的任何分片而不能将其丢弃，因为丢弃了一个IP分片，它就再也不会到来了。</li><li>现在，TCP实现了一种称为选择确认的方式，接收端会显式告诉发送端需要重传哪些分段而不需要重传哪些分段。这无疑避免了重传风暴。</li></ul><h5 id="TCP序列号的回绕的问题"><a href="#TCP序列号的回绕的问题" class="headerlink" title="TCP序列号的回绕的问题"></a>TCP序列号的回绕的问题</h5><ul><li>TCP的序列号回绕会引起很多的问题，比如序列号为s的分段发出之后，m秒后，序列号比s小的序列号为j的分段发出，只不过此时的j比上一个s多了一圈，这就是回绕问题，那么如果这后一个分段到达接收端，这就会引发彻底乱序-本来j该在s后面，结果反而到达前面了，这种乱序是TCP协议检查不出来的。我们仔细想一下，这种情况确实会发生，数据分段并不是一个字节一个字节发送出去的，如果存在一个速率为1Gbps的网络，TCP发送端1秒会发送125MB的数据，32位的序列号空间能传输2的32次方个字节，也就是说32秒左右就会发生回绕，我们知道这个值远小于MSL值，因此会发生的。</li><li>有个细节可能会引起误会，那就是TCP的窗口大小空间是序列号空间的一半，这样恰好在满载情况下，数据能填满发送窗口和接收窗口，序列号空间正好够用。然而事实上，TCP的初始序列号并不是从0开始的，而是随机产生的(当然要辅助一些更精妙的算法)，因此如果初始序列号比较接近2的32次方，那么很快就会回绕。</li><li>当然，如今可以用时间戳选项来辅助作为序列号的一个识别的部分，接收端遇到回绕的情况，需要比较时间戳，我们知道，时间戳是单调递增的，虽然也会回绕，然而回绕时间却要长很多。这只是一种策略，在此不详谈。还有一个很现实的问题，理论上序列号会回绕，但是实际上，有多少TCP的端点主机直接架设在1G的网络线缆两端并且接收方和发送方的窗口还能恰好被同时填满。另外，就算发生了回绕，也不是一件特别的事情，回绕在计算机里面太常见了，只需要能识别出来即可解决，对于TCP的序列号而言，在高速网络(点对点网络或者以太网)的两端，数据发生乱序的可能性很小，因此当收到一个序列号突然变为0或者终止序列号小于起始序列号的情况后，很容易辨别出来，只需要和前一个确认的分段比较即可，如果在一个经过路由器的网络两端，会引发IP数据报的顺序重排，对于TCP而言，虽然还会发生回绕，也会慢得多，且考虑到拥塞窗口(目前还没有引入)一般不会太大，窗口也很难被填满到65536。</li></ul><h5 id="超时重传和收到3个冗余ACK后重传"><a href="#超时重传和收到3个冗余ACK后重传" class="headerlink" title="超时重传和收到3个冗余ACK后重传"></a>超时重传和收到3个冗余ACK后重传</h5><ul><li>这两种重传的意义是不同的，超时重传一般是因为网络出现了严重拥塞(没有一个分段到达，如果有的话，肯定会有ACK的，若是正常ACK，则重置重传定时器，若是冗余ACK，则可能是个别报文丢失或者被重排序，若连续3个冗余ACK，则很有可能是个别分段丢失)，此时需要更加严厉的缩小拥塞窗口，因此此时进入慢启动阶段。而收到3个冗余ACK后说明确实有中间的分段丢失，然而后面的分段确实到达了接收端，这因为这样才会发送冗余ACK，这一般是路由器故障或者轻度拥塞或者其它不太严重的原因引起的，因此此时拥塞窗口缩小的幅度就不能太大，此时进入快速重传/快速恢复阶段。</li></ul><h5 id="为何收到3个冗余ACK后才重传"><a href="#为何收到3个冗余ACK后才重传" class="headerlink" title="为何收到3个冗余ACK后才重传"></a>为何收到3个冗余ACK后才重传</h5><ul><li>这是一种权衡的结构，收到两个或者一个冗余ACK也可以重传，但是这样的话可能或造成不必要的重传，因为两个数据分段发生乱序的可能性不大，超过三个分段发生乱序的可能性才大，换句话说，如果仅仅收到一个乱序的分段，那很可能被中间路由器重排了，那么另一个分段很可能马上就到，然而如果连续收到了3个分段都没能弥补那个缺漏，那很可能是它丢失了，需要重传。因此3个冗余ACK是一种权衡，在减少不必要重传和确实能检测出单个分段丢失之间所作的权衡。注意，冗余ACK是不能捎带的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术&amp;学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>go学习</title>
      <link href="/2020/03/19/go%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/03/19/go%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="Learn-GO"><a href="#Learn-GO" class="headerlink" title="Learn GO"></a>Learn GO</h2><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><h4 id="学习编写测试"><a href="#学习编写测试" class="headerlink" title="学习编写测试"></a>学习编写测试</h4><ul><li>编写一个测试</li><li>让编译通过</li><li>运行测试，查看失败原因并检查错误消息是很有意义的</li><li>编写足够的代码以使测试通过</li><li>重构</li><li>通过编写自动测试代码来保证测试的覆盖率和准确性，不需要通过运行软件来查看代码的正确性</li><li>学习TDD（Test drive develop）的过程，通过将问题分解成更小的可测试的组件，编写软件将会更加轻松</li><li>在测试中完善开发需求<h3 id="学习编写注释"><a href="#学习编写注释" class="headerlink" title="学习编写注释"></a>学习编写注释</h3></li><li>在方法中适当编写注释可以方便得生成文档，方便后续维护</li><li>使用代码示例，代码示例将作为测试用例的一部分</li></ul><h3 id="数组与迭代"><a href="#数组与迭代" class="headerlink" title="数组与迭代"></a>数组与迭代</h3><ul><li>数组前指定长度的为数组，不指定长度的为切片</li></ul><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">for</span> _, num := <span class="keyword">range</span> array &#123;</span><br><span class="line">sum += num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用<code>range</code>迭代<br>  range迭代每次会返回数组的索引与值，这里使用空白符<code>_</code>替代返回的索引</li></ul><h3 id="结构体-方法-接口"><a href="#结构体-方法-接口" class="headerlink" title="结构体 方法 接口"></a>结构体 方法 接口</h3><h4 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Rectangle <span class="keyword">struct</span> &#123;</span><br><span class="line">width  <span class="keyword">float64</span></span><br><span class="line">height <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为结构体添加方法"><a href="#为结构体添加方法" class="headerlink" title="为结构体添加方法"></a>为结构体添加方法</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Area returns the area of a rectangle</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rect Rectangle)</span> <span class="title">Area</span><span class="params">()</span> <span class="title">float64</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> rect.width &lt;= <span class="number">0.0</span> || rect.height &lt;= <span class="number">0.0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rect.height * rect.width</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>即可使用<code>rectangle.Area()</code>来调用Area()方法</li></ul><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><ul><li>golang的接口继承是隐式的，只要传入的类型与接口的定义相匹配，则编译正确</li></ul><p>例如：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Shape defines the shape interface</span></span><br><span class="line"><span class="keyword">type</span> Shape <span class="keyword">interface</span> &#123;</span><br><span class="line">Area() <span class="keyword">float64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>定义了一个<code>IShape</code>接口，接口中定义了一个Area函数，则上面的<code>Rectangle</code>结构体与该接口匹配，且不需要在<code>Rectangle</code>中显示声明</li><li>通过声明一个接口，辅助函数能从具体类型解耦而只关心方法本身需要做的工作。</li></ul><h4 id="表格驱动测试"><a href="#表格驱动测试" class="headerlink" title="表格驱动测试"></a>表格驱动测试</h4><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestArea</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    areaTests := []<span class="keyword">struct</span> &#123;</span><br><span class="line">        shape Shape</span><br><span class="line">        want  <span class="keyword">float64</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        &#123;Rectangle&#123;<span class="number">12</span>, <span class="number">6</span>&#125;, <span class="number">72.0</span>&#125;,</span><br><span class="line">        &#123;Circle&#123;<span class="number">10</span>&#125;, <span class="number">314.1592653589793</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, tt := <span class="keyword">range</span> areaTests &#123;</span><br><span class="line">        got := tt.shape.Area()</span><br><span class="line">        <span class="keyword">if</span> got != tt.want &#123;</span><br><span class="line">            t.Errorf(<span class="string">"got %.2f want %.2f"</span>, got, tt.want)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如上例代码，创建一个匿名结构体，含有两个域：<code>shape</code>和<code>want</code>,后续就可以方便的向其中添加测试用例，并且不会破坏之前的测试</li></ul><h3 id="指针与错误"><a href="#指针与错误" class="headerlink" title="指针与错误"></a>指针与错误</h3><h4 id="结构体数据的私有性"><a href="#结构体数据的私有性" class="headerlink" title="结构体数据的私有性"></a>结构体数据的私有性</h4><ul><li>在 Go 中，如果一个符号（例如变量、类型、函数等）是以小写符号开头，那么它在 定义它的包之外 就是私有的。</li></ul><h4 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h4><ul><li>当你传值给函数或方法时，Go 会复制这些值。因此，如果你写的函数需要更改状态，你就需要用指针指向你想要更改的值</li><li>Go 取值的副本在大多数时候是有效的，但是有时候你不希望你的系统只使用副本，在这种情况下你需要传递一个引用。例如，非常庞大的数据或者你只想有一个实例（比如数据库连接池）</li></ul><h4 id="nil"><a href="#nil" class="headerlink" title="nil"></a>nil</h4><ul><li>指针可以是 nil</li><li>当函数返回一个的指针，你需要确保检查过它是否为 nil，否则你可能会抛出一个执行异常，编译器在这里不能帮到你</li><li>nil 非常适合描述一个可能丢失的值</li></ul><h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><ul><li>错误是在调用函数或方法时表示失败的</li><li>通过测试我们得出结论，在错误中检查字符串会导致测试不稳定。因此，我们用一个有意义的值重构了，这样就更容易测试代码，同时对于我们 API 的用户来说也更简单。</li><li>错误处理的故事远远还没有结束，你可以做更复杂的事情，这里只是抛砖引玉。后面的部分将介绍更多的策略。</li><li>不要只是检查错误，要优雅地处理错误</li></ul><h4 id="从现有的类型中创建新的类型"><a href="#从现有的类型中创建新的类型" class="headerlink" title="从现有的类型中创建新的类型"></a>从现有的类型中创建新的类型</h4><ul><li>用于为值添加更多的领域内特定的含义</li><li>可以让你实现接口</li></ul><h3 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h3><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><ul><li>map用法为<code>map[type1]type2</code></li><li>例如：<code>map[string]string</code>，定义了一个key为string类型，value为string类型的map</li></ul><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li><p>map查找可以返回两个值,若要查询的key-vlaue存在，则第一个值为查到的value，第二个值为<code>bool</code>值<code>true</code>;否则第一个值为空，第二个值为<code>false</code></p></li><li><p>例如:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dictionary <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">value,result := dictionary[key]</span><br></pre></td></tr></table></figure></li><li><p>map是引用类型，所以不需要指针传递就可以修改原数据</p></li><li><p>由于map是引用类型，所以map可以是<code>nil</code>值，如果使用一个nil的map，就会得到nil指针异常，导致程序终止</p></li><li><p>所以永远不要初始化一个空的map变量,例如<code>var m map[string]string</code></p></li><li><p>可以通过下列方法初始化空map</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dictionary = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// OR</span></span><br><span class="line"></span><br><span class="line">dictionary = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>)</span><br></pre></td></tr></table></figure></li><li><p>这两种方法都可以创建一个空的 hash map 并指向 dictionary。这确保永远不会获得 nil 指针异常</p></li></ul><h3 id="Mocking"><a href="#Mocking" class="headerlink" title="Mocking"></a>Mocking</h3><ul><li>反引号语法是创建string的另一种形式，例如<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">want := <span class="string">`3 </span></span><br><span class="line"><span class="string">2</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">GO!`</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><ul><li>goroutines 是 Go 的基本并发单元，它让我们可以同时运行多项任务</li><li>anonymous functions（匿名函数），我们用它来启动每个并发进程</li><li>channels，用来组织和控制不同进程之间的交流，使我们能够避免 race condition（竞争条件）(锁) 的问题。</li><li>the race detector（竞争探测器） 帮助我们调试并发代码的问题。</li></ul><h4 id="channels"><a href="#channels" class="headerlink" title="channels"></a>channels</h4><ul><li><p>channel 内部就是一个带锁的队列</p></li><li><p><a href="https://www.cnblogs.com/oxspirt/p/7124291.html" target="_blank" rel="noopener">https://www.cnblogs.com/oxspirt/p/7124291.html</a></p></li><li><p><a href="https://www.cnblogs.com/wdliu/p/9272220.html" target="_blank" rel="noopener">https://www.cnblogs.com/wdliu/p/9272220.html</a></p></li><li><p>channel分为三种类型</p><ul><li>只读chan：<code>var readOnlyChan &lt;-chan int</code>(使用<code>&lt;-chan</code>定义)</li><li>只写chan：<code>var writeOnlyChan chan&lt;- int</code>(使用<code>chan&lt;-</code>定义)</li><li>读写chan: <code>var normalchan chan int</code>(使用<code>chan</code>定义)</li></ul></li><li><p>一般定义只读和只写的管道意义不大，更多时候我们可以在参数传递时候指明管道可读还是可写，即使当前管道是可读写的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只能向channel中存数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        c &lt;- i</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//只能取channel中的数据</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(c &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> c &#123;</span><br><span class="line">        fmt.Println(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    c := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> send(c)</span><br><span class="line">    <span class="keyword">go</span> get(c)</span><br><span class="line">    time.Sleep(time.Second*<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>需要注意的是：</p><ul><li>管道如果未关闭，在读取超时会则会引发deadlock异常</li><li>管道如果关闭进行写入数据会pannic</li><li>当管道中没有数据时候再行读取或读取到默认值，如int类型默认值是0</li><li>使用range循环管道，如果管道未关闭会引发deadlock错误。</li><li>如果采用for死循环已经关闭的管道，当管道没有数据时候，读取的数据会是管道的默认值，并且循环不会退出。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ch:= <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">10</span>)</span><br><span class="line">ch&lt;-<span class="string">"value"</span>         <span class="comment">//写数据</span></span><br><span class="line">value := &lt;-ch       <span class="comment">//读数据</span></span><br><span class="line">value,ok := &lt;-ch    <span class="comment">//优雅地读数据</span></span><br><span class="line"><span class="built_in">close</span>(ch)           <span class="comment">//关闭管道</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>带缓冲区channe和不带缓冲区channel</p><ul><li>带缓冲区chan: 定义时声明了缓冲区大小(长度),可以保存多个数据</li><li>不带缓冲区chan: 定义时未声明缓冲区，只能存一个数据，只有当该数据被取出时才能存下一个数据<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">10</span>) <span class="comment">//带缓冲区的chan</span></span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)    <span class="comment">//不带缓冲区的chan</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>channel频率控制</p><ul><li>在对channel进行读写的时，go还提供了非常人性化的操作，那就是对读写的频率控制，通过time.Ticke实现<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    requests:= <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span> ,<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">1</span>;i&lt;<span class="number">5</span>;i++&#123;</span><br><span class="line">        requests&lt;-i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(requests)</span><br><span class="line">    limiter := time.Tick(time.Second*<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> req:=<span class="keyword">range</span> requests&#123;</span><br><span class="line">        &lt;-limiter</span><br><span class="line">        fmt.Println(<span class="string">"requets"</span>,req,time.Now()) <span class="comment">//执行到这里，需要隔1秒才继续往下执行，time.Tick(timer)上面已定义</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h4><ul><li>可帮助你同时在多个 channel 上等待。</li><li>有时你想在你的某个「案例」中使用 time.After 来防止你的系统被永久阻塞</li><li>select-case实现非阻塞channel<ul><li>原理通过select+case加入一组管道，当满足（这里说的满足意思是有数据可读或者可写)select中的某个case时候，那么该case返回，若都不满足case，则走default分支。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">    <span class="keyword">for</span> i :=<span class="number">1</span> ; i&lt;<span class="number">10</span> ;i++  &#123;</span><br><span class="line">     c &lt;-i</span><br><span class="line">     fmt.Println(<span class="string">"send data : "</span>,i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    resch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>,<span class="number">20</span>)</span><br><span class="line">    strch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>,<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">go</span> send(resch)</span><br><span class="line">    strch &lt;- <span class="string">"wd"</span></span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> a := &lt;-resch:</span><br><span class="line">        fmt.Println(<span class="string">"get data : "</span>, a)</span><br><span class="line">    <span class="keyword">case</span> b := &lt;-strch:</span><br><span class="line">        fmt.Println(<span class="string">"get data : "</span>, b)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">"no channel actvie"</span>)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="httptest标准库"><a href="#httptest标准库" class="headerlink" title="httptest标准库"></a>httptest标准库</h4><ul><li>一种方便地创建测试服务器的方法，这样你就可以进行可靠且可控的测试。</li><li>使用和 net/http 相同的接口作为「真实的」服务器会和真实环境保持一致，并且只需更少的学习。</li></ul><h3 id="json-路由-嵌入"><a href="#json-路由-嵌入" class="headerlink" title="json 路由 嵌入"></a>json 路由 嵌入</h3><h4 id="嵌入"><a href="#嵌入" class="headerlink" title="嵌入"></a>嵌入</h4><ul><li><p>Go 没有提供典型的，类型驱动的子类化概念，但它具有通过在结构或接口中嵌入类型来“借用”一部分实现的能力。</p></li><li><p>例如：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PlayerServer <span class="keyword">struct</span> &#123;</span><br><span class="line">store PlayerStore</span><br><span class="line">http.Handler</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过在<code>PlayerServer</code>结构体中<strong>嵌入</strong><code>http.handler</code>类型，这样，<code>PlayerServer</code>就可以拥有<code>http.handler</code>所有的公开方法以及属性</p></li><li><p>你必须小心使用嵌入类型，因为你将公开所有嵌入类型的公共方法和字段。在我们的例子中它是可以的，因为我们只是嵌入了 <code>http.Handler</code> 这个 接口。</p></li><li><p>如果我们懒一点，嵌入了 <code>http.ServeMux</code>（混合类型），它仍然可以工作 但 <code>PlayerServer</code> 的用户就可以给我们的服务器添加新路由了，因为 <code>Handle(path, handler)</code>会公开。</p></li><li><p>路由。标准库为你提供了易于使用的类型来处理路由。它完全支持 http.Handler 接口，因为你可以将路由分配给 Handler，而路由本身也是 Handler。它没有你可能期望的某些特性，例如路径变量（例如 /users/{id}）。你可以自己轻易地解析这些信息，但如果它成了负担，你可能会考虑查看其它路由库。大多数流行的库都坚持标准库的实现 http.Handler 的理念。</p></li><li><p>类型嵌入。我们对这项技术略有提及，但你可以从 Effective Go 了解更多信息。如果你应该从中得到一个收获，那就是它极其有用，但是 总是考虑你的公开 API，只有适合被公开的才公开。</p></li><li><p>JSON 反序列化和序列化。标准库使得序列化和反序列化数据变得非常简单。它也是开放的配置，你可以根据需要自定义这些数据转换的工作方式。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术&amp;学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计网复习</title>
      <link href="/2020/03/03/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/"/>
      <url>/2020/03/03/%E8%AE%A1%E7%BD%91%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="计算机网络基础复习"><a href="#计算机网络基础复习" class="headerlink" title="计算机网络基础复习"></a>计算机网络基础复习</h2><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><p><img src="https://pic.downk.cc/item/5e5dcf1b98271cb2b80e5be8.jpg" alt></p><h3 id="Tcp三次握手四次挥手"><a href="#Tcp三次握手四次挥手" class="headerlink" title="Tcp三次握手四次挥手"></a>Tcp三次握手四次挥手</h3><p><img src="https://pic.downk.cc/item/5e5ddd4598271cb2b811d97c.jpg" alt></p><ul><li><p>为什么需要三次握手呢？为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</p></li><li><p>比如：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段，但是server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求，于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了，由于client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据，但server却以为新的运输连接已经建立，并一直等待client发来数据。所以没有采用“三次握手”，这种情况下server的很多资源就白白浪费掉了。</p></li></ul><p><img src="https://pic.downk.cc/item/5e5dde2e98271cb2b8121412.jpg" alt></p><ul><li>为什么需要四次挥手呢？TCP是全双工模式，当client发出FIN报文段时，只是表示client已经没有数据要发送了，client告诉server，它的数据已经全部发送完毕了；但是，这个时候client还是可以接受来server的数据；当server返回ACK报文段时，表示它已经知道client没有数据发送了，但是server还是可以发送数据到client的；当server也发送了FIN报文段时，这个时候就表示server也没有数据要发送了，就会告诉client，我也没有数据要发送了，如果收到client确认报文段，之后彼此就会愉快的中断这次TCP连接。</li></ul><h3 id="Http"><a href="#Http" class="headerlink" title="Http"></a>Http</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li>超文本传输协议</li><li>基于请求与响应，无状态的</li><li><strong>应用层的协议</strong></li><li>基于TCP/IP传输数据<h4 id="http-1"><a href="#http-1" class="headerlink" title="http/1"></a>http/1</h4></li><li>持久连接(长连接)</li><li>节约带宽</li><li>HOST域</li><li>管道机制</li><li>分块传输编码</li></ul><h4 id="http-2"><a href="#http-2" class="headerlink" title="http/2"></a>http/2</h4><ul><li>多路复用</li><li>服务器推送</li><li>头信息压缩</li><li>二进制协议</li></ul><h4 id="http-1与http-2对比"><a href="#http-1与http-2对比" class="headerlink" title="http/1与http/2对比"></a>http/1与http/2对比</h4><ul><li>http/2性能更优</li><li>http/2支持多路复用：通过单一的http/2连接请求发起多重的请求-响应消息，多个stream共享一个tcp连接，从而实现多流并行</li><li>http报文格式<ul><li>请求报文包含请求行与首部行<ul><li>请求行：<ul><li>包含：请求方法、请求路径、版本</li></ul></li><li>首部行：<ul><li>包含首部数据，key-value形式</li></ul></li></ul></li><li>响应报文包含状态行与首部行<ul><li>状态行：<ul><li>包含：版本、状态码、短语</li></ul></li><li>首部行：<ul><li>包含：首部数据，key-value形式</li></ul></li></ul></li></ul></li></ul><p><img src="https://pic.downk.cc/item/5e5dc38098271cb2b80b920a.jpg" alt></p><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><ul><li>https是一种通过计算机网络进行安全通信的传输协议，经由http协议进行通信，利用SSL/TLS建立全信道，加密数据包</li><li>SSL/TLS是传输层的加密协议</li><li>https主要用于提供对网站服务器的身份认证，同时保护交换数据的隐私与完整性</li></ul><h3 id="Http-VS-Https"><a href="#Http-VS-Https" class="headerlink" title="Http VS Https"></a>Http VS Https</h3><h4 id="http特性"><a href="#http特性" class="headerlink" title="http特性"></a>http特性</h4><ul><li>无状态：协议对客户端没有状态存储，对事物处理没有“记忆”能力，比如访问一个网站需要反复进行登录操作</li><li>无连接：HTTP/1.1之前，由于无状态特点，每次请求需要通过TCP三次握手四次挥手，和服务器重新建立连接。比如某个客户机在短时间多次请求同一个资源，服务器并不能区别是否已经响应过用户的请求，所以每次需要重新响应请求，需要耗费不必要的时间和流量。</li><li>基于请求和响应：基本的特性，由客户端发起请求，服务端响应</li><li>简单快速、灵活</li><li>通信使用明文、请求和响应不会对通信方进行确认、无法保护数据的完整性</li></ul><h4 id="https特性"><a href="#https特性" class="headerlink" title="https特性"></a>https特性</h4><ul><li><p>基于http协议</p></li><li><p>通过SSL或TLS提供加密处理数据、验证对方身份、数据完整性保护</p></li><li><p>内容加密：采用混合加密技术，中间者无法直接查看明文内容</p><ul><li>混合加密：结合非对称加密和对称加密技术。客户端使用对称加密生成密钥对传输数据进行加密，然后使用非对称加密的公钥再对秘钥进行加密，所以网络上传输的数据是被秘钥加密的密文和用公钥加密后的秘密秘钥，因此即使被黑客截取，由于没有私钥，无法获取到加密明文的秘钥，便无法获取到明文数据。</li><li>数字摘要：通过单向hash函数对原文进行哈希，将需加密的明文“摘要”成一串固定长度(如128bit)的密文，不同的明文摘要成的密文其结果总是不相同，同样的明文其摘要必定一致，并且即使知道了摘要也不能反推出明文</li><li>数字签名：数字签名建立在公钥加密体制基础上，是公钥加密技术的另一类应用。它把公钥加密技术和数字摘要结合起来，形成了实用的数字签名技术</li></ul></li><li><p>验证身份：通过证书认证客户端访问的是自己的服务器</p></li><li><p>保护数据完整性：防止传输的内容被中间人冒充或篡改</p></li><li><p>SSL建立连接过程<br><img src="https://pic.downk.cc/item/5e5de29798271cb2b81332fb.jpg" alt></p></li></ul><p>①客户端的浏览器向服务器发送请求，并传送客户端SSL 协议的版本号，加密算法的种类，产生的随机数，以及其他服务器和客户端之间通讯所需要的各种信息。</p><p>②服务器向客户端传送SSL 协议的版本号，加密算法的种类，随机数以及其他相关信息，同时服务器还将向客户端传送自己的证书。</p><p>③客户端利用服务器传过来的信息验证服务器的合法性，服务器的合法性包括：证书是否过期，发行服务器证书的CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配。如果合法性验证没有通过，通讯将断开；如果合法性验证通过，将继续进行第四步。</p><p>④用户端随机产生一个用于通讯的“对称密码”，然后用服务器的公钥（服务器的公钥从步骤②中的服务器的证书中获得）对其加密，然后将加密后的“预主密码”传给服务器。</p><p>⑤如果服务器要求客户的身份认证（在握手过程中为可选），用户可以建立一个随机数然后对其进行数据签名，将这个含有签名的随机数和客户自己的证书以及加密过的“预主密码”一起传给服务器。</p><p>⑥如果服务器要求客户的身份认证，服务器必须检验客户证书和签名随机数的合法性，具体的合法性验证过程包括：客户的证书使用日期是否有效，为客户提供证书的CA 是否可靠，发行CA 的公钥能否正确解开客户证书的发行CA 的数字签名，检查客户的证书是否在证书废止列表（CRL）中。检验如果没有通过，通讯立刻中断；如果验证通过，服务器将用自己的私钥解开加密的“预主密码”，然后执行一系列步骤来产生主通讯密码（客户端也将通过同样的方法产生相同的主通讯密码）。</p><p>⑦服务器和客户端用相同的主密码即“通话密码”，一个对称密钥用于SSL 协议的安全数据通讯的加解密通讯。同时在SSL 通讯过程中还要完成数据通讯的完整性，防止数据通讯中的任何变化。</p><p>⑧客户端向服务器端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知服务器客户端的握手过程结束。</p><p>⑨服务器向客户端发出信息，指明后面的数据通讯将使用的步骤⑦中的主密码为对称密钥，同时通知客户端服务器端的握手过程结束。</p><p>⑩SSL 的握手部分结束，SSL 安全通道的数据通讯开始，客户和服务器开始使用相同的对称密钥进行数据通讯，同时进行通讯完整性的检验。</p><h4 id="Https优点"><a href="#Https优点" class="headerlink" title="Https优点"></a>Https优点</h4><ul><li>使用Https协议可以认证用户和服务器，确保数据发送到正确的客户机和服务器</li><li>https协议是由SSL+http协议构建的可进行加密传输，身份认证的网络协议，要比http协议安全，可防止数据在传输过程中不被窃取，修改，确保数据的完整性</li><li>https是现行网络架构下最完全的解决方案，虽然不是绝对安全，但是大幅增加了中间人攻击的成本</li></ul><h4 id="Https缺点"><a href="#Https缺点" class="headerlink" title="Https缺点"></a>Https缺点</h4><ul><li>https协议握手阶段比较费时，加长了页面的加载时间</li><li>https连接缓存不如http高效，会增加数据开销，甚至会影响已有的安全措施</li><li>https的安全不是绝对的，在面对黑客攻击，拒绝服务攻击和服务器劫持时起不到作用</li><li>SSL证书通常需要绑定ip，不能在同一个ip上绑定多个域名，IPv4资源无法支撑这种消耗</li><li>增加成本，SSL协议的加密算法和SSL的交互次数将占用一定的计算资源和服务器成本</li><li>https协议的加密范围有限，SSL证书的信用链体系并不安全，特别是某些国家可以控制CA根证书的情况下，中间人攻击一样可行</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术&amp;学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows安装DCM4CHEE</title>
      <link href="/2020/02/21/Windows%E5%AE%89%E8%A3%85DCM4CHEE/"/>
      <url>/2020/02/21/Windows%E5%AE%89%E8%A3%85DCM4CHEE/</url>
      
        <content type="html"><![CDATA[<p><em>TODO ：了解单点登录系统、ldap</em></p><h2 id="Dcm4chee及相关服务简介"><a href="#Dcm4chee及相关服务简介" class="headerlink" title="Dcm4chee及相关服务简介"></a>Dcm4chee及相关服务简介</h2><ul><li><a href="https://github.com/dcm4che/dcm4chee-arc-light" target="_blank" rel="noopener">Dcm4chee</a><ul><li>基于<a href="http://www.mozilla.org/MPL/1.1/" target="_blank" rel="noopener">Mozilla Public License Version 1.1</a>协议，可以商用</li><li>基于Java，是一个运行在wildfly容器中的Web项目</li><li>用于图像管理和图像归档，实现了dicom服务和HL7标准</li></ul></li><li><a href="https://github.com/dcm4che/dcm4che" target="_blank" rel="noopener">Dcm4che</a><ul><li>基于<a href="http://www.mozilla.org/MPL/1.1/" target="_blank" rel="noopener">Mozilla Public License Version 1.1</a>协议，可以商用</li><li>基于Java的开源工具包，实现了dicom标准</li><li>具有Dicom图像的读取，发送，检索等功能</li></ul></li><li><a href="https://github.com/wildfly/wildfly" target="_blank" rel="noopener">Wildfly</a><ul><li>基于<a href="https://github.com/wildfly/wildfly/blob/master/LICENSE.txt" target="_blank" rel="noopener">LGPL协议</a>，可以商用</li><li>Wildfly是一个开源的基于JavaEE的轻量级应用服务器，用于管理与部署java项目，java项目部署在wildfly中，可以方便地进行监控与管理</li></ul></li><li>LDAP服务<ul><li>Lightweight Directory Access Protocol-轻量级目录访问协议</li><li>用于多站点之间的统一身份认证，从而实现单点登录</li></ul></li></ul><h2 id="Dcm4chee功能简介"><a href="#Dcm4chee功能简介" class="headerlink" title="Dcm4chee功能简介"></a>Dcm4chee功能简介</h2><ul><li><p>提供了一个完善的Web管理界面</p></li><li><p>可以接收其他设备传输的任何符合Dicom标准的文件并存储</p></li><li><p>可以接收其他设备的符合Dicom标准的查询请求，故可以作为Pac服务器，worklist服务器等</p></li><li><p>本身不能伪造数据进行数据模拟，数据只能通过外部传入dcm4chee系统中</p><h4 id="上传Dicom文件示例："><a href="#上传Dicom文件示例：" class="headerlink" title="上传Dicom文件示例："></a>上传Dicom文件示例：</h4><ol><li>通过<code>jdicom</code>工具进行上传<ol><li>打开jdicom工具包中的<code>StorageSCU</code>工具</li><li>修改AE与端口为Dcm4chee中的AE与端口(默认为AE：DCM4CHEE，port：11112)</li><li>点击<code>connect</code>，然后点击<code>send</code>进行上传</li></ol></li></ol><ul><li>jdicom上传示例：<br><a href="https://pic.downk.cc/item/5e4f882248b86553ee3449a9.jpg" target="_blank" rel="noopener"><img src="https://pic.downk.cc/item/5e4f882248b86553ee3449a9.jpg" alt></a></li></ul><ol><li>通过dcm4chee网页进行上传<ol><li>通过<code>Navigation--&gt;Studies--&gt;More functions--&gt;Upload DICOM Object</code>上传Dicom文件</li></ol></li></ol><ul><li>Dcm4chee网页上传示例：<br><a href="https://pic.downk.cc/item/5e4f885648b86553ee3456dd.jpg" target="_blank" rel="noopener"><img src="https://pic.downk.cc/item/5e4f885648b86553ee3456dd.jpg" alt></a></li></ul></li></ul><h4 id="WorkList服务示例"><a href="#WorkList服务示例" class="headerlink" title="WorkList服务示例"></a>WorkList服务示例</h4><ul><li>首先需要上传Dicom文件</li><li>在<code>http://localhost:8080/dcm4chee-arc/ui2/#/study/study</code>界面中列出所有图像</li><li>点击图像信息列最前方的三个点，点击加号<br><a href="https://pic.downk.cc/item/5e4f8b6048b86553ee3504e3.jpg" target="_blank" rel="noopener"><img src="https://pic.downk.cc/item/5e4f8b6048b86553ee3504e3.jpg" alt></a></li><li>在弹出的<code>Create new MWL</code>界面中，点击<code>Add new attribute</code>,添加<code>Modality</code>字段<br><a href="https://pic.downk.cc/item/5e4f8bf048b86553ee3523b0.jpg" target="_blank" rel="noopener"><img src="https://pic.downk.cc/item/5e4f8bf048b86553ee3523b0.jpg" alt></a></li><li>在新增的<code>Modality</code>字段中输入值<code>MR</code>,然后Create即可添加一条MR的WorkList数据<br><a href="https://pic.downk.cc/item/5e4f8c3548b86553ee353176.jpg" target="_blank" rel="noopener"><img src="https://pic.downk.cc/item/5e4f8c3548b86553ee353176.jpg" alt></a><br><a href="https://pic.downk.cc/item/5e4f8dad48b86553ee358e63.jpg" target="_blank" rel="noopener"><img src="https://pic.downk.cc/item/5e4f8dad48b86553ee358e63.jpg" alt></a></li><li>在工作站中配置WorkList服务，即可使用DCM4CHEE的worklist服务<ul><li>IP：localhost</li><li>Port：11112</li><li>AE：DCM4CHEE</li></ul></li></ul><h4 id="病人信息管理"><a href="#病人信息管理" class="headerlink" title="病人信息管理"></a>病人信息管理</h4><ul><li>病人信息与上传的Dicom文件关联</li><li>也可通过<code>Patients--&gt;More functions</code>新建病人信息<br><a href="https://pic.downk.cc/item/5e4f8d9248b86553ee35884d.jpg" target="_blank" rel="noopener"><img src="https://pic.downk.cc/item/5e4f8d9248b86553ee35884d.jpg" alt></a></li></ul><h2 id="Dcm4chee安装"><a href="#Dcm4chee安装" class="headerlink" title="Dcm4chee安装"></a>Dcm4chee安装</h2><ul><li><em>Dcm4chee支持多种数据库，例如H2，PostgreSQL，Mysql等，可以在官方<a href="https://github.com/dcm4che/dcm4chee-arc-light/releases" target="_blank" rel="noopener">releases</a>中下载</em></li><li><em>不要使用Sqlserver版本，官方并未测试sqlserver版本</em></li><li><em>这里选用了Mysql版本进行安装，后期在其他平台安装也适用</em></li></ul><h4 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h4><ul><li>Java版本：&gt;=java SE8 &amp;&amp; X86版(OpenJdk和Oracle JDK均可)</li><li>下载<a href="http://wildfly.org/downloads" target="_blank" rel="noopener">Wildfly</a>(version&gt;=wildfly14)</li><li>下载<a href="http://dev.mysql.com/downloads/mysql" target="_blank" rel="noopener">Mysql</a>(Version&gt;=5.7.9)并安装</li><li>下载LDAP服务器，选用<a href="http://directory.apache.org/apacheds/downloads.html" target="_blank" rel="noopener">Apache DS</a>(version&gt;=Apache DS 2.0.0-M20)<ul><li>官方推荐了三种LDAP服务器，分别是<a href="http://www.openldap.org/software/download" target="_blank" rel="noopener">OpenLDAP</a>,<a href="https://backstage.forgerock.com/#/downloads/enterprise/OpenDJ" target="_blank" rel="noopener">OpenDJ</a>,<a href="http://directory.apache.org/apacheds/downloads.html" target="_blank" rel="noopener">Apache DS</a></li><li>OpenLDAP配置较为繁琐，并且全程需命令行配置</li><li>OpenDJ官方已升级为付费项目，免费版已停止下载</li><li>ApacheDS配置较为简单，需要命令行配置的部分较少</li></ul></li><li>下载LDAP服务管理器 <a href="https://directory.apache.org/studio/downloads.html" target="_blank" rel="noopener">Apache Directory Studio</a>(version&gt;= Apache Directory Studio 2.0.0-M9)</li></ul><h4 id="安装注意点"><a href="#安装注意点" class="headerlink" title="安装注意点"></a>安装注意点</h4><ul><li>安装流程按照<a href="https://github.com/dcm4che/dcm4chee-arc-light/wiki/Installation" target="_blank" rel="noopener">官方指导</a>进行即可</li><li>启动Wildfly之前，需要配置Wildfly管理员用户，使用wildfly提供的脚本进行配置，脚本路径为<code>%wildfly_Home%/bin/add-user.bat</code>(windows)或<code>%wildfly_Home%/bin/add-user.sh</code>(linux)</li><li>启动Wildfly之后，可以访问<code>http://localhost:9990/console</code>进入wildfly控制台</li></ul><p>wildfly控制台示例：<br><a href="https://pic.downk.cc/item/5e4f6f4f48b86553ee2ed005.jpg" target="_blank" rel="noopener"><img src="https://pic.downk.cc/item/5e4f6f4f48b86553ee2ed005.jpg" alt></a></p><ul><li><p><a href="https://github.com/dcm4che/dcm4chee-arc-light/wiki/Installation" target="_blank" rel="noopener">官方指导</a>中留下的坑：</p><ol><li>Initialize Database这一节中，按照指导创建数据库之后，在Setup WildFly这一节的第10步，添加wildfly数据源的时候，数据源名称要与创建的数据库名称一致，<strong>否则会连不上mysql数据库</strong></li><li>Import default configuration into LDAP Server节的第1步，通过Apache Directory Studio连接LDAP服务时，连接参数要与Setup LDAP Server–&gt;Apache DS 2.0.0中第2步中的连接参数相同，或者可以直接用Setup LDAP Server–&gt;Apache DS 2.0.0中用到的连接，<strong>否则会连不上ldap服务</strong></li><li>在Setup WildFly节的第1步，将Dcm4chee中的配置文件复制到wildfly中之后，需要修改dcm4chee-arc/ldap.properties文件中配置，修改<code>java.naming.provider.url</code>与<code>java.naming.security.principal</code>字段，使起与之前配置的ldap服务相吻合，<strong>否则会无法启动Wildfly</strong></li><li>在Setup WildFly节的第10步，添加了Mysql数据源以及数据库连接之后，需要修改wildfly配置文件中的mysql的数据库连接字符串，在Setup WildFly节的第2步生成的<code>dcm4chee-arc.xml</code>即为wildfly的启动配置文件，在该文件中查找<code>subsystem xmlns=&quot;urn:jboss:domain:datasources:5.0&quot;</code>节点，在其中寻找<code>datasource jndi-name=&quot;java:/PacsDS&quot; pool-name=&quot;pacsds&quot;</code>节点，修改其中的<code>connection-url</code>节点的数据,在mysql连接字符串后添加<code>?serverTimezone=UTC</code>，<strong>否则会因为时区不对无法连接mysql服务</strong><ul><li>例如修改前<code>connection-url</code>的数据为<code>jdbc:mysql://127.0.0.1:3306/pacsdb</code></li><li>修改后的数据为<code>jdbc:mysql://127.0.0.1:3306/pacsdb?serverTimezone=UTC</code></li></ul></li><li>如果需要配置dcm4chee项目为外网可以访问，需要修改<code>dcm4chee-arc.xml</code>文件中的<code>subsystem xmlns=&quot;urn:jboss:domain:webservices:2.0&quot;</code>节点，<code>interface name=&quot;management&quot;</code>节点，<code>interface name=&quot;public&quot;</code>与<code>interface name=&quot;unsecure&quot;</code>节点，将节点中的<code>127.0.0.1</code>全部修改为<code>0.0.0.0</code></li><li>一定要有X86的jdk，<strong>否则ldap服务无法正常运行</strong>，最好同时安装x64与x86的jdk</li><li>jdk版本一定要大于等于jdk8，<strong>否则wildfly服务无法正常运行</strong></li></ol></li><li><p>按照以上步骤安装完成dcm4chee后，就可以访问<code>http://localhost:8080/dcm4chee-arc/ui2</code>进入dcm4chee的管理界面。</p></li></ul><p>dcm4chee管理界面：<br><a href="https://pic.downk.cc/item/5e4f71a648b86553ee2f5c74.jpg" target="_blank" rel="noopener"><img src="https://pic.downk.cc/item/5e4f71a648b86553ee2f5c74.jpg" alt></a></p><ul><li>同时，可以访问<code>http://localhost:9990/console/index.html#runtime</code>进入wildfly运行项目管理界面进行dcm4chee网站项目的监控与管理</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术&amp;学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 项目搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>摩尔投票算法</title>
      <link href="/2020/01/03/%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95/"/>
      <url>/2020/01/03/%E6%91%A9%E5%B0%94%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="摩尔投票算法"><a href="#摩尔投票算法" class="headerlink" title="摩尔投票算法"></a>摩尔投票算法</h3><ul><li>来源： <a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">LeetCode-169 求众数</a></li><li>算法描述：<ul><li>依次用数组中2个元素抵消法，相等+1，不等减-1，为0时重新取新的下标元素。这样超过一半的元素肯定是抵消不完的，就直接返回之前赋值的元素即可。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">MajorityElement</span>(<span class="params"><span class="keyword">int</span>[] nums</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> countFlag = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.Length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (countFlag == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    result = nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                countFlag += (result == nums[i]) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>站着挣钱</title>
      <link href="/2019/12/06/%E7%AB%99%E7%9D%80%E6%8C%A3%E9%92%B1/"/>
      <url>/2019/12/06/%E7%AB%99%E7%9D%80%E6%8C%A3%E9%92%B1/</url>
      
        <content type="html"><![CDATA[<p>我好不容易开了网站，做了社区，我还得拉拢豪绅？<br>对<br>还得巧立名目？<br>对<br>还得看他妈的脸色？<br>对<br>那我不成了跪着要饭的了么？<br>那你这么说，开网站做社区还真就是跪着要饭的。就这，多少人想跪还没这门子呢？<br>我问你，我为什么要做社区?我就是腿脚不利索，跪不下去。<br>原来你是想站着挣钱，那还是回山里吧。<br>哎？这我就不明白了，我已经当了大V了，怎么还不如一个公关啊？<br>百姓眼里，你是大V，可是黄四郎眼里，你就是跪着要饭的。挣钱嘛，生意，不寒碜。<br>寒碜。很他妈寒碜！<br>那你想站着，还是想挣钱呢？<br>我是站着，还把钱挣了。<br>（摇头）挣不成。<br>挣不成？（把枪拍桌上）这个能不能挣钱？<br>能挣，山里<br>（拍惊堂木）这个呢？<br>能挣，跪着<br><img src="https://puui.qpic.cn/fans_admin/0/3_454945618_1575613662829/0" alt></p>]]></content>
      
      
      <categories>
          
          <category> 404 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 251 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工厂模式の第一次</title>
      <link href="/2019/11/25/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E3%81%AE%E7%AC%AC%E4%B8%80%E6%AC%A1/"/>
      <url>/2019/11/25/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E3%81%AE%E7%AC%AC%E4%B8%80%E6%AC%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><blockquote><ul><li>工厂模式主要作用是为创建对象提供接口，将创建对象的过程分离出来，实现创建者与调用者的隔离，提高程序的灵活性。</li><li>主要目标： <ul><li>分离实例化对象的过程，用工厂方法代替<code>new</code>操作</li><li>将<strong>选择实现类、创建对象、对象的统一管理和控制</strong>等功能分离，使调用者跟实现类解耦</li></ul></li><li>主要分类： <ul><li>简单工厂模式</li><li>工厂方法模式</li><li>抽象工厂模式</li></ul></li></ul></blockquote><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><blockquote><ul><li>又称为<strong>静态工厂方法</strong></li><li>主要组成结构： <ul><li>抽象产品： 定义产品的基本属性</li><li>具体产品： 定义具体产品的属性</li><li>工厂类： 创建具体产品</li></ul></li></ul></blockquote><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><strong>抽象产品</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IHero</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Attack</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体产品</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IronMan</span> : <span class="title">IHero</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Attack</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$"Iron Man Attack"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Thor</span> : <span class="title">IHero</span>   </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Attack</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$"Thor Attack"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>工厂类</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SimpleFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IHero <span class="title">CreateHeroFactory</span>(<span class="params"><span class="keyword">string</span> heroType</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (heroType)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"IronMan"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> IronMan();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"Thor"</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Thor();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用方法</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UseSimpleFactory();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UseSimpleFactory</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HeroFactory heroFactory = <span class="keyword">new</span> HeroFactory();</span><br><span class="line">    IHero ironMan = heroFactory.CreateHeroFactory(<span class="string">"IronMan"</span>);</span><br><span class="line">    IHero thor = heroFactory.CreateHeroFactory(<span class="string">"Thor"</span>);</span><br><span class="line">    ironMan.Attack();</span><br><span class="line">    thor.Attack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><blockquote><ul><li>简单工厂模式初步实现了对象实例化方法的剥离，但是，简单工厂对于拓展开发不是很友好，以后若是要拓展新的产品则需要修改工厂类的原始代码，这显然是违反了<strong>开闭原则</strong>(对拓展开放，对修改关闭)的</li></ul></blockquote><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><blockquote><ul><li>由于简单工厂模式违反了开闭原则，在大型的项目长期开发中不适合使用，为了不违反开闭原则，在简单工厂代码的基础上稍作修改即可</li><li>主要组成结构： <ul><li>抽象产品： 定义产品的基本属性</li><li>具体产品： 定义具体产品的属性</li><li>抽象工厂： 定义工厂的基本属性</li><li>具体工厂： 创建具体产品</li></ul></li></ul></blockquote><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p><strong>抽象产品</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IHero</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Attack</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体产品</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IronMan</span> : <span class="title">IHero</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Attack</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$"Iron Man Attack"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Thor</span> : <span class="title">IHero</span>   </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Attack</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$"Thor Attack"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>抽象工厂</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IHero</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Attack</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体工厂</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ThorFactory</span> : <span class="title">IHeroFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IHero <span class="title">CreateHero</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">IronManFactory</span> : <span class="title">IHeroFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> IHero <span class="title">CreateHero</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IronMan();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用方法</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UseFactoryMethod();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">UseFactoryMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IHeroFactory heroFactory = <span class="keyword">new</span> IronManFactory();</span><br><span class="line">    <span class="keyword">var</span> ironMan = heroFactory.CreateHero();</span><br><span class="line">    ironMan.Attack();</span><br><span class="line"></span><br><span class="line">    IHeroFactory thorFactory = <span class="keyword">new</span> ThorFactory();</span><br><span class="line">    <span class="keyword">var</span> thor = thorFactory.CreateHero();</span><br><span class="line">    thor.Attack();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><blockquote><ul><li>工厂方法模式有效的解决了项目拓展的问题，拓展时不需要修改原来的代码，但是工厂中一般可以生产很多种产品，所以在工厂方法模式上再进一步优化，就可以得到抽象工厂模式</li></ul></blockquote><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><blockquote><ul><li>抽象工厂其实就是在工厂方法模式的基础上，在具体工厂中可以创建多种具体产品，更加贴近实际应用。具体结构与工厂方法模式类似。</li></ul></blockquote><h3 id="拓展：单例模式"><a href="#拓展：单例模式" class="headerlink" title="拓展：单例模式"></a>拓展：单例模式</h3><blockquote><ul><li>工厂模式拓展出来的模式中应用最广泛的就是单例模式</li><li>由于将对象的创建通过工厂类控制，所以可以有效的控制实例化的数量，从而实现单例模式。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术&amp;学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-28：KMP算法</title>
      <link href="/2019/11/09/KMP%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/"/>
      <url>/2019/11/09/KMP%E7%AE%97%E6%B3%95%E6%B5%85%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h3 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h3><blockquote><ul><li>一种较为高效的字符串查找匹配算法</li><li>算法目的是：在匹配失败时，利用原有的匹配信息，尽量减少重新匹配的次数</li><li>主字符串只遍历一遍，子字符串通过有限状态机进行匹配</li></ul></blockquote><blockquote><ul><li>首先根据子字符串的匹配状态构建有限状态机</li><li>然后可以使用有限状态机对主字符串进行遍历匹配</li></ul></blockquote><p>详情解析<a href="https://leetcode-cn.com/problems/implement-strstr/solution/shen-ru-qian-chu-kmp-suan-fa-yu-ping-jie-by-zohary/" target="_blank" rel="noopener">LeetCodeCN-28题解</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单文档型数据库对比总结</title>
      <link href="/2019/11/04/%E5%8D%95%E6%96%87%E6%A1%A3%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93/"/>
      <url>/2019/11/04/%E5%8D%95%E6%96%87%E6%A1%A3%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="单文档数据库对比总结"><a href="#单文档数据库对比总结" class="headerlink" title="单文档数据库对比总结"></a>单文档数据库对比总结</h2><h3 id="单文档数据库定义"><a href="#单文档数据库定义" class="headerlink" title="单文档数据库定义"></a>单文档数据库定义</h3><blockquote><ul><li>无服务端，不需要配置服务器也可正常使用</li><li>数据存储在单个文件中，可以随意移动</li></ul></blockquote><h3 id="目标数据库要求"><a href="#目标数据库要求" class="headerlink" title="目标数据库要求"></a>目标数据库要求</h3><blockquote><ul><li>使用方便，尽量少的安装配置步骤</li><li>安全性好，可以对数据库文件进行加密</li><li>开发接口齐全</li><li>客户端使用方便或开发方便</li></ul></blockquote><h3 id="单文档数据库对比"><a href="#单文档数据库对比" class="headerlink" title="单文档数据库对比"></a>单文档数据库对比</h3><table><thead><tr><th>数据库名称</th><th>客户端</th><th>客户端使用难度</th><th>需要安装环境</th><th>需要服务端</th><th>安装包大小</th><th>可加密</th><th>*读写性能</th><th>使用难度</th><th>开发接口</th></tr></thead><tbody><tr><td>LiteDB</td><td>有</td><td>简单</td><td>否</td><td>否</td><td>\</td><td>可加密</td><td>(W)13.643s<br>(R)1ms</td><td>简单</td><td>齐全</td></tr><tr><td>sqlite</td><td>有</td><td>简单</td><td>否</td><td>否</td><td>\</td><td>不可加密</td><td>(W)16.282s<br>(R)13ms</td><td>简单</td><td>齐全</td></tr><tr><td>firebird</td><td>有</td><td>复杂</td><td>是</td><td>是</td><td>9MB</td><td>可加密</td><td>\</td><td>较复杂</td><td>齐全</td></tr><tr><td>Berkeley DB</td><td>否</td><td>\</td><td>否</td><td>否</td><td>\</td><td>可加密</td><td>\</td><td>复杂</td><td>不齐全</td></tr><tr><td>SQL Server CE</td><td>有</td><td>简单</td><td>是</td><td>否</td><td>3MB</td><td>可加密</td><td>(W)24.709s<br>(R)8ms</td><td>简单</td><td>齐全</td></tr></tbody></table><blockquote><ul><li><strong>*读写性能：插入10w条数据，单条数据约5kb；读取10w条数据，单条数据约5kb</strong></li></ul></blockquote><blockquote><ul><li>LiteDB数据库管理器：<a href="https://github.com/julianpaulozzi/LiteDbExplorer" target="_blank" rel="noopener">LiteDbExplorer</a></li><li>sqlite数据库管理器：<a href="https://sqlitestudio.pl/index.rvt" target="_blank" rel="noopener">sqliteStudio</a></li><li>Sql Server CE数据库管理器：sdfViewer注册码：<ul><li>Name: <a href="http://www.cr173.com" target="_blank" rel="noopener">www.cr173.com</a></li><li>key: X8bJCvrXWFtwertpPEBz+Q==</li></ul></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术&amp;学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SqlServer查看数据库连接情况</title>
      <link href="/2019/10/31/SqlServer%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%83%85%E5%86%B5/"/>
      <url>/2019/10/31/SqlServer%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%83%85%E5%86%B5/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>使用Sqlserver作为数据库时,如果需要查看某个数据库当前的连接情况，可以使用一下sql语句：</li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> </span><br><span class="line">[<span class="keyword">Master</span>].[dbo].[SYSPROCESSES] <span class="keyword">WHERE</span> [DBID] </span><br><span class="line"><span class="keyword">IN</span> </span><br><span class="line">(</span><br><span class="line">  <span class="keyword">SELECT</span> </span><br><span class="line">   [DBID]</span><br><span class="line">  <span class="keyword">FROM</span> </span><br><span class="line">   [<span class="keyword">Master</span>].[dbo].[SYSDATABASES] </span><br><span class="line">  <span class="keyword">WHERE</span> </span><br><span class="line">   <span class="keyword">NAME</span>=<span class="string">'你的数据库名称'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术&amp;学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#递归删除空文件夹</title>
      <link href="/2019/10/29/C-%E9%80%92%E5%BD%92%E5%88%A0%E9%99%A4%E7%A9%BA%E6%96%87%E4%BB%B6%E5%A4%B9/"/>
      <url>/2019/10/29/C-%E9%80%92%E5%BD%92%E5%88%A0%E9%99%A4%E7%A9%BA%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="C-递归删除某路径下空文件夹"><a href="#C-递归删除某路径下空文件夹" class="headerlink" title="C#递归删除某路径下空文件夹"></a>C#递归删除某路径下空文件夹</h1><blockquote><ul><li>C#递归删除某路径下的所有空文件夹</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DeleteEmptyFolders</span>(<span class="params"><span class="keyword">string</span> location</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!Directory.Exists(location))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (Directory.GetDirectories(location).Length != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> subDirs = Directory.GetDirectories(location);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> subDir <span class="keyword">in</span> subDirs)</span><br><span class="line">        &#123;</span><br><span class="line">            DeleteEmptyFolders(subDir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (IsFolderEmpty(location) &amp;&amp; location != RootPath)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$"Delete location: <span class="subst">&#123;location&#125;</span>"</span>);</span><br><span class="line">        Directory.Delete(location);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsFolderEmpty</span>(<span class="params"><span class="keyword">string</span> folderLocation</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Directory.Exists(folderLocation))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> filesAndFolders = Directory.GetFileSystemEntries(folderLocation);</span><br><span class="line">        <span class="keyword">return</span> filesAndFolders.Length == <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术&amp;学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code segment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wpf初探</title>
      <link href="/2019/09/18/wpf%E5%88%9D%E6%8E%A2/"/>
      <url>/2019/09/18/wpf%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="wpf初探"><a href="#wpf初探" class="headerlink" title="wpf初探"></a>wpf初探</h1><hr><h1 id="Binding"><a href="#Binding" class="headerlink" title="Binding"></a>Binding</h1><blockquote><ul><li>自定义的类想要实现binding的功能，需要实现 <strong>INotifyPropertyChanged</strong> 接口</li><li>数据源：只要是一个对象，并且通过属性( Property )公开自己的数据，就可以作为数据源</li><li>binding数据源与控件 <code>this.textboxName.SetBinding(TextBox.TextProperty,new Binding(&quot;Name&quot;){Source = stu})</code></li><li>除了在C#代码中Binding，还可以直接在XAML代码中Binding其他控件的属性。</li><li>通常Binding数据的方法有：<ul><li>普通CLR类型的单个对象作为Source，包括.NET Framework 自带类型的对象和用具自定义的对象</li><li>普通CLR集合类型对象作为Source，包括数组，List&lt; T &gt;,  ObservableCollection&lt; T &gt;</li><li>将 ADO.NET 数据对象指定为Source， 包括 DataTable 和 DataView等</li><li>使用 XmlDataProvider 把 xml 数据指定为Source</li><li>将依赖（Dependency Object）指定为Source</li><li>将容器的 DataContext 指定为 Source</li><li>通过ElementName 指定 Source</li><li>通过 Binding的 RelativeSource 属性相对地指定 Source</li><li>将 ObjectDataProvider 对象指定为 Source</li><li>将Linq检索得到的数据对象作为 Source</li></ul></li><li>容器的 DataContext 属性是会被子元素继承的属性。</li></ul></blockquote><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><blockquote><ul><li>依赖属性<ul><li>自己没有值，但是能通过使用binding从数据源获取值得属性</li><li>拥有依赖属性的对象称为依赖对象</li><li>wpf所有UI控件都是依赖对象</li></ul></li><li>在依赖对象中声明依赖属性需要使用 <code>public static readonly</code></li><li>依赖属性已经实现了<code>INotifyPropertyChanged</code>接口</li><li>附加属性<ul><li>附加属性的本质是依赖属性。</li><li>将属性与宿主解耦，让数据类型的设计更加灵活。</li></ul></li><li>??</li></ul></blockquote><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><blockquote><ul><li>CLR事件模型中，分为：<ul><li>事件拥有者</li><li>事件</li><li>事件响应者</li><li>事件处理者</li><li>订阅关系</li></ul></li><li>CLR事件模型的弊端：<ul><li>每队消息是“发送–&gt;相应”关系，必须建立显示的点对点订阅关系。</li><li>事件的宿主必须能够直接访问事件的响应者，不然无法建立订阅关系。</li></ul></li><li>WPF路由事件机制：<ul><li>事件拥有者和事件响应者没有直接的订阅关系</li><li>事件拥有者只负责激发事件，将事件在visual tree中传播</li><li>事件响应者有事件侦听器，当事件传递到该节点时，其事件处理器就会被调用，并决定是否继续传播事件（使用<code>RoutedEventArgs.Handled</code>标记）</li></ul></li><li>可以在cs代码中为控件绑定事件侦听器，也可以在XAML中直接在控件商绑定事件侦听器</li><li>路由事件有三种路由策略：<ul><li>Bubble,冒泡式：路由事件由事件的激发者出发向它的上级容器一层一层路由，直至最外层容器。</li><li>Tunnel，隧道式：由Visual Tree的树根向事件激发控件路由。</li><li>Direct，直达式：模仿CLR直接事件，直接将事件消息送达事件处理器。</li></ul></li><li>附加事件：在非UIElement派生类中注册的路由事件（<code>本质上只算是路由事件的一种用法而非一种新概念</code>）<ul><li>无法自己激发路由事件也无法侦听路由事件</li><li>附加事件路由第一站是激发它的元素</li><li>附加事件一般定义在Binding、Mouse、Keyboard这种全局Helper类中。</li></ul></li></ul></blockquote><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><blockquote><ul><li>命令与事件的区别：<ul><li>命令可以约束消息处理代码</li><li>命令可以约束步骤逻辑</li></ul></li><li>命令系统的要素：<ul><li>命令：实现<code>ICommand</code>接口，使用最多的是<code>RoutedCommand</code></li><li>命令源：命令发送者，实现<code>ICommandSource</code>接口（只包含<code>Command</code>、<code>CommandParameter</code>、<code>CommandTarget</code>三个属性）</li><li>命令目标：实现<code>IInputElement</code>接口的类</li><li>命令关联：将外围逻辑与命令关联起来，比如<strong>执行前对命令是否可以执行进行判断，命令执行之后还有哪些后续工作等</strong></li></ul></li><li>使用自定义命令：<ul><li>声明并定义命令</li><li>将命令赋值给命令源（发送者）并<strong>指定快捷键（命令可以方便地指定快捷键）</strong></li><li>指定命令目标   <code>Tips:这一步有没有必要？因为在XAML中声明命令是不需要指定命令目标的</code></li><li>创建命令关联</li><li>将命令关联安置在外围控件上</li></ul></li><li><strong><code>CanExecute</code>事件的激发频率较高，为了尽量避免降低性能，在处理完后需要将<code>e.Handled</code>设置为<code>true</code></strong></li><li><strong>命令关联（CommandBinding</strong>一定要绑定在命令目标的外围控件上，不然无法捕获到<code>CanExecute</code>和<code>Executed</code>等路由事件  </li><li>常用命令库：<ul><li><code>ApplicationCommands</code></li><li><code>ComponentCommands</code></li><li><code>NavigationCommands</code></li><li><code>MediacCommands</code></li><li><code>EditingCommands</code></li></ul></li></ul><ul><li>命令参数：给命令目标传递参数，可以使同一个命令实现不同的操作。</li><li></li></ul></blockquote><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><blockquote><ul><li>每个WPF界面元素都有<code>Resources</code>属性，这个属性类型为<code>ResouresDictionary</code>，使用 <strong>键-值</strong> 对的形式存储资源</li><li>静态资源与动态资源<ul><li>静态资源（<code>Static</code>）在程序载入内存时对资源一次性引用，之后就不再访问这个资源。</li><li>动态资源（<code>Dynamic</code>）在程序运行过程中仍然会访问这个资源，在程序运行过程中还有可能修改的资源应该使用<code>DynamciResource</code></li></ul></li><li>在<strong>资源词典</strong>里的资源称为“WPF资源”或者“对象资源”，应用程序内嵌的资源称为“程序集资源”或“二进制资源”</li><li>向WPF中添加二进制资源：<ul><li>如果添加的是字符串而非文件，则可以使用<code>Properties</code>名称空间中的<code>Resources.resx</code>资源文件。该文件也用<strong>键-值</strong>对储存数据。</li><li><strong>为了让XAML编译器能够访问<code>Resources</code>类，一定要把<code>Resources.resx</code>的访问级别由Internal改为Public</strong></li></ul></li><li>使用<code>Resources.resx</code>最大的好处是便于国际化，修改界面中的值直接修改资源即可。</li></ul></blockquote><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><blockquote><ul><li>WPF中控件分为两大类：<ul><li><code>ControlTemplate</code>是算法内容的表现形式，决定了控件的外观，是控件的外衣</li><li><code>DataTemplate</code>是数据内容的表现形式，决定数据的显示样式，是数据的外衣</li></ul></li><li><code>DataTemplate</code>完成了数据驱动界面，常用于三处：<ul><li>ContentControl的ContentTemplate属性，相当于给ContentControl的内容穿外衣。</li><li>ItemsControl的ItemTemplate属性，相当于给ItemControl的数据条目穿衣。</li><li>GridViewColumn的CellTemplate属性，相当于给GridViewColumn单元格里的数据穿衣服。</li></ul></li><li><code>ControlTemplate</code>主要用于两处：<ul><li>更换ControlTemplate改变控件外观，使之具有更优的用户使用体验及外观。</li><li>借助ControlTemplate，程序员与设计师并行工作，先使用标准控件编程，设计完成后只需把新的ControlTemplate应用到程序中即可。</li></ul></li></ul></blockquote><h1 id="XAML"><a href="#XAML" class="headerlink" title="XAML"></a>XAML</h1><blockquote><ul><li><code>x:Name</code>实例化控件对象的引用变量的名称，方便查找相应控件</li><li><code>x:Key</code>为资源添加用于检索的索引。形成<code>Key-Value</code>键值对。</li><li>LogicalTree：描述了界面的整体框架；WPF大部分特性（属性值继承，事件路由以及样式）都是通过逻辑树进行工作的。</li><li>VisualTree：描述了界面的所有细节；使用样式可以改变视觉树上的元素，可以使用Style.TargetType属性来选择希望修改的特定元素，甚至当空间属性发生变化时，通过触发器自动完成修改。可以为控件创建新的模板。</li></ul></blockquote><h1 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h1><blockquote><ul><li>Grid：网格布局，可以自定义行与列的数量，行高，列宽开调整控件布局。类似以Html中的Table，适用于：<ul><li>UI布局的大框架设计</li><li>大量UI元素需要成行或者成列对齐</li><li>UI整体尺寸改变时，元素需要保持固有的高度和宽度比例</li><li>UI后期可能有焦大的变更或拓展</li></ul></li><li>StackPanel：栈式面板。可将包含的元素在竖直或者水平方向上排成一条直线，移除一个元素后，后排的元素会自动向前移动填补空缺。适用于：<ul><li>同类元素需要紧凑排列</li><li>移除其中的元素后能够自动补缺的布局或者动画</li></ul></li><li>Canvas：画布。内部元素可以使用以像素为单位的绝对坐标（<code>Canvas.X</code>和<code>Canvas.Y</code>）进行定位。适用于：<ul><li>一经设计基本上不会再有改动的小型布局（如：图标）</li><li>艺术性比较强的布局</li><li>需要大量使用横纵坐标进行绝对定位的布局。</li><li>依赖于横纵坐标的动画</li></ul></li><li>DockPanel：泊靠式面板。元素内部可以选择泊靠方向。<ul><li>内部元素根据<code>DockPanel.Dock</code>属性规定的方向泊靠。</li><li><code>LastChildFill</code>属性，默认为True，此时DockPanel内最后一个元素会将内部所有剩余空间充满。</li></ul></li><li>WrapPanel：自动折行面板。内部元素在排满一行后能自动折行，类似Html中的流式布局。</li></ul></blockquote><h1 id="异步修改UI"><a href="#异步修改UI" class="headerlink" title="异步修改UI"></a>异步修改UI</h1><blockquote><ul><li>BackgroundWorker：可以直接使用控件，每一步修改可以直接应用于控件</li><li>Dispatcher：不可以直接使用控件，每一步修改都需要向Dispatcher队列注册。</li></ul></blockquote><h1 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h1><blockquote><ul><li>MVVM = Model-View-ViewModel</li><li>Model层负责定义数据，获取数据</li><li>ViewModel层负责逻辑处理，处理Model层的数据，用于View层的数据绑定。</li><li>View层，即XAML代码，负责UI，与ViewModel层绑定。</li><li>从而解耦UI与逻辑，消灭XAML的后台代码。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术&amp;学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#学习--进阶篇</title>
      <link href="/2019/09/18/C-%E5%AD%A6%E4%B9%A0-%E8%BF%9B%E9%98%B6%E7%AF%87/"/>
      <url>/2019/09/18/C-%E5%AD%A6%E4%B9%A0-%E8%BF%9B%E9%98%B6%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="C-学习–进阶篇"><a href="#C-学习–进阶篇" class="headerlink" title="C#学习–进阶篇"></a>C#学习–进阶篇</h1><hr><h1 id="Q1-为何区分值类型和引用类型"><a href="#Q1-为何区分值类型和引用类型" class="headerlink" title="Q1.为何区分值类型和引用类型"></a>Q1.为何区分值类型和引用类型</h1><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><blockquote><ul><li>引用类型可以实现接口，值类型当中的结构体也可以实现接口；</li><li>引用类型和值类型都继承自System.Object类。</li></ul></blockquote><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><blockquote><ul><li>引用类型可以派生出新的类型，而值类型不能；</li><li>引用类型可以包含null值，值类型不能（可空类型功能允许将 null 赋给值类型）；</li><li>引用类型变量的赋值只复制对对象的引用，而不复制对象本身。而将一个值类型变量赋给另一个值类型变量时，将复制包含的值</li></ul></blockquote><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><blockquote><ul><li>数组的元素不管是引用类型还是值类型，都存储在托管堆上。</li><li>引用类型在栈中存储一个引用，其实际的存储位置位于托管堆。简称引用类型部署在托管推上。而值类型总是分配在它声明的地方：作为字段时，跟随其所属的变量（实 例）存储；作为局部变量时，存储在栈上。（栈的内存是自动释放的，堆内存是.NET中会由GC来自动释放）</li></ul></blockquote><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><blockquote><ul><li>值类型在内存管理方面具有更好的效率，并且不支持多态，适合用做存储数据的载体；</li><li>引用类型支持多态，适合用于定义应用程序的行为。</li></ul></blockquote><br><br><hr><h1 id="Q2-为何要装箱和拆箱"><a href="#Q2-为何要装箱和拆箱" class="headerlink" title="Q2.为何要装箱和拆箱"></a>Q2.为何要装箱和拆箱</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><ul><li>装箱是将值类型转换为引用类型 ；拆箱是将引用类型转换为值类型。</li></ul></blockquote><h2 id="为何要装箱"><a href="#为何要装箱" class="headerlink" title="为何要装箱"></a>为何要装箱</h2><blockquote><ul><li>较为典型的场景是：某方法或者容器为了保证通用，将参数定为object，那么在值类型作为参数时就需要装箱</li></ul><hr><ul><li>道理很简单，按理说C#被设计成一种完全面向对象的语言。因此，包括数字、字符、日期、布尔值等等在内的一切，都是对象。似乎只需要一种方式来对待这些对象就可以了。<br><br>但是C#不是只停留在学院中和理想中，它必须为性能而妥协，我们知道，对于CPU来说，处理一个完整的对象，需要很多的指令，对于内存来说，又需要很多的内存。如果连整数都是对象，那么性能自然很低。C#于是使用了一种机制，使得这些基本类型在一般的编程中被当作非对象的简单类型处理，在另一些场合，又允许它们被视作是一个对象。这种机制就是装箱和拆箱。<br><br>装箱后的对象看上去和一个对象一样，拥有方法，可以当作object处理，拆箱后的变量，看上去又如同C语言中的那些变量、结构体一样，可以直接参与运算和处理。<br><p align="right">—<a href="https://bbs.csdn.net/topics/390624164?page=1" target="_blank" rel="noopener">CSDN某帖子四楼</a></p></li></ul></blockquote><hr><h1 id="Q3-协变与逆变"><a href="#Q3-协变与逆变" class="headerlink" title="Q3.协变与逆变"></a>Q3.协变与逆变</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><blockquote><p><em>查了半天，还是<a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98" target="_blank" rel="noopener">wiki</a>讲的最明白，其他的网站都描述的太抽象了。</em>  </p><ul><li>协变与逆变是一种术语，描述泛型的一个特性，这个特性具体解释如下：</li><li>在一门程序设计语言的类型系统中，一个类型规则或者类型构造器是：<ul><li>协变（covariant），如果它保持了子类型序关系≦。该序关系是：子类型≦基类型。</li><li>逆变（contravariant），如果它逆转了子类型序关系。</li><li>不变（invariant），如果上述两种均不适用。    </li></ul></li></ul></blockquote><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><blockquote><ul><li>这样的定义有点抽象，举个栗子来描述一下定义：  </li><li>如果Cat是Animal的子类型，那么Cat类型的表达式可用于任何出现Animal类型表达式的地方。  </li><li>那么我们在这两个类上各构造一个数组，Cat[ ] 与 Animal[ ] (数组是一种泛型吧)<ul><li>如果Cat[ ] 也是Animal[ ] 的子类，那么数组类型构造器就是 <strong>协变</strong>，因为通过这个构造器构造的对象保持了其构造类型的父子关系。</li><li>如果Animal[ ] 变为了Cat[ ] 的子类，那么该类型构造器就是 <strong>逆变</strong>，因为通过这个构造器构造的对象逆变了其构造类型的父子关系。</li><li>以上两者均不是，则该构造器是 <strong>不变</strong> 的。</li></ul></li><li>一般的函数类型，<strong>对于输入参数是逆变的，对于输出参数是协变的。</strong><ul><li>例如： 函数类型Cat-&gt;Cat可安全用于期望Cat-&gt;Animal的地方；类似地，函数类型Animal-&gt;Animal可用于期望Cat-&gt;Animal的地方——典型地，在 Animal a=Fn(Cat(…)) 这种语境下进行调用，由于 Cat 是 Animal 的子类所以即使 Fn 接受一只 Animal 也同样是安全的。一般规则是：<br>S1 → S2 ≦ T1 → T2 当T1 ≦ S1且S2 ≦ T2.</li></ul></li><li>在 C# 中，每个泛型接口的类型参数都可被标注为协变（out）、逆变（in）或不变（不标注）。例如，可以定义一个接口 IEnumerator<t> 作为只读的迭代器，并声明它在其类型参数上具有协变性,代码如下：</t></li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> interface IEnumerator&lt;out T&gt;</span><br><span class="line"> &#123;</span><br><span class="line">    T Current</span><br><span class="line">    &#123;</span><br><span class="line">        get;</span><br><span class="line">    &#125;</span><br><span class="line">    bool MoveNext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>通过这样声明，IEnumerator<t> 就会在其类型参数上具有协变性。例如，IEnumerator&lt; Cat &gt; 是 IEnumerator&lt; Animal &gt; 的子类型。</t></li><li>协/逆变合法性：<ul><li>非泛型类型（类、结构、枚举等）既协变合法、也逆变合法。</li><li>类型参数 T 如果没有标 in，那么是协变合法；如果没有标 out，那么是逆变合法。</li><li>如果类型 A 是协 / 逆变合法，那么相应的数组类型 A[ ] 是协 / 逆变合法（C# 的数组是协变的）</li><li>泛型类型 G&lt;A1, A2, …, An&gt; 是协 / 逆变合法，如果对于每个类型参数 Ai：<ul><li>Ai 是协 / 逆变合法，当且仅当 G 中的第 i 个参数被声明为协变</li><li>Ai 是逆 / 协变合法（反转），当且仅当 G 中的第 i 个参数被声明为逆变</li><li>Ai 既协变合法又逆变合法，当且仅当 G 中的第 i 个参数被声明为不变</li></ul></li></ul></li></ul></blockquote><hr><h1 id="Q4-C-中造成内存泄露的主要原因"><a href="#Q4-C-中造成内存泄露的主要原因" class="headerlink" title="Q4.C#中造成内存泄露的主要原因"></a>Q4.C#中造成内存泄露的主要原因</h1><h2 id="事件-大多数内存泄露的原因"><a href="#事件-大多数内存泄露的原因" class="headerlink" title="事件(大多数内存泄露的原因)"></a>事件(大多数内存泄露的原因)</h2><blockquote><ul><li>C#的GC是使用标记清除算法来自动回收垃圾的。具体的流程是，从GCRoot开始遍历托管堆内所有对象，将遍历到的对象标记为可达对象，在遍历完成后，回收所有的非可达对象。<ul><li>注册在事件中的订阅者们由于事件一直存在，所以这些订阅者都一直处于可达状态,注册在事件上的对象一直存在于内存中，造成内存泄露。</li></ul></li></ul></blockquote><h2 id="非托管对象"><a href="#非托管对象" class="headerlink" title="非托管对象"></a>非托管对象</h2><blockquote><ul><li>非托管对象必须手动释放，必须通过Dispose释放非托管资源。可以使用 <strong>using</strong> 语句隐式调用Dispose,也可以使用Try/finally语句显式调用Dispose</li><li>创建非托管对象一定要注意命名规范，才能避免忘记释放该对象。</li><li>使用using语句处理非托管资源示例：</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.IO;</span><br><span class="line">using System.Text.RegularExpressions;</span><br><span class="line"></span><br><span class="line">public class WordCount</span><br><span class="line">&#123;</span><br><span class="line">   private String filename = String.Empty;</span><br><span class="line">   private int nWords = 0;</span><br><span class="line">   private String pattern = @&quot;\b\w+\b&quot;; </span><br><span class="line"></span><br><span class="line">   public WordCount(string filename)</span><br><span class="line">   &#123;</span><br><span class="line">      if (! File.Exists(filename))</span><br><span class="line">         throw new FileNotFoundException(&quot;The file does not exist.&quot;);</span><br><span class="line">      </span><br><span class="line">      this.filename = filename;</span><br><span class="line">      string txt = String.Empty;</span><br><span class="line">      using (StreamReader sr = new StreamReader(filename)) &#123;</span><br><span class="line">         txt = sr.ReadToEnd();</span><br><span class="line">      &#125;</span><br><span class="line">      nWords = Regex.Matches(txt, pattern).Count;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public string FullName</span><br><span class="line">   &#123; get &#123; return filename; &#125; &#125;</span><br><span class="line">   </span><br><span class="line">   public string Name</span><br><span class="line">   &#123; get &#123; return Path.GetFileName(filename); &#125; &#125;</span><br><span class="line">   </span><br><span class="line">   public int Count </span><br><span class="line">   &#123; get &#123; return nWords; &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集合-静态对象"><a href="#集合-静态对象" class="headerlink" title="集合/静态对象"></a>集合/静态对象</h2><blockquote><ul><li>集合需要及时clear，尤其是将一些方法中的临时变量添加到集合中后，会导致集合膨胀，使其内存泄露。</li><li>静态字段在整个程序运行期间都不会释放，所以尽量减少其可见域就减少了其内存泄露的可能性。</li><li>尽量不要声明静态的集合，静态的集合很容易造成内存泄露。</li></ul></blockquote><hr><h1 id="Q5-Task-与-Parallel"><a href="#Q5-Task-与-Parallel" class="headerlink" title="Q5.Task 与 Parallel"></a>Q5.Task 与 Parallel</h1><p><strong>Updating</strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术&amp;学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#学习--初级篇</title>
      <link href="/2019/09/18/C-%E5%AD%A6%E4%B9%A0-%E5%88%9D%E7%BA%A7%E7%AF%87/"/>
      <url>/2019/09/18/C-%E5%AD%A6%E4%B9%A0-%E5%88%9D%E7%BA%A7%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="C-学习–初级学习"><a href="#C-学习–初级学习" class="headerlink" title="C#学习–初级学习"></a>C#学习–初级学习</h1><hr><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><blockquote><ul><li>参数使用驼峰命名法</li><li>其余命名均使用帕斯卡命名法</li><li>属性和关联字段命名：关联字段使用驼峰命名法，属性使用帕斯卡命名法</li></ul></blockquote><h3 id="类型、存储、变量"><a href="#类型、存储、变量" class="headerlink" title="类型、存储、变量"></a>类型、存储、变量</h3><blockquote><ul><li>类型是模板，需要实例化才能使用</li><li>dynamic 动态类型</li><li>C#中数值类型不具有bool意义</li><li>除了16种预定义类型，还有6种可以自定义的类型<ul><li>类 (class)</li><li>结构 (struct)</li><li>数组 (array)</li><li>枚举 (enum)</li><li>委托 (delegate)</li><li>接口 (interface)</li></ul></li><li>引用类型的所有数据成员都在堆里</li><li>匿名类型(var)需要属性名称、数据类型、属性顺序都完全相同才能“类型兼容”</li><li>匿名类型(var)是只读的，一旦实例化就不可变</li></ul></blockquote><h3 id="类、方法"><a href="#类、方法" class="headerlink" title="类、方法"></a>类、方法</h3><blockquote><ul><li>访问控制有5种<ul><li>private:仅该类内部可访问</li><li>public：任何类均可访问</li><li>protected：所有继承该类的类可访问</li><li>internal：仅该程序集 <strong>(.dll &amp;&amp; .exe)</strong> 内所有类可访问</li><li>protected internal：继承该类的类或该程序集内的类可访问</li></ul></li><li>类的成员默认为private，也可以显式声明，public必须显式声明</li><li>var关键字<ul><li>只能在方法里使用，不能用于字段</li><li>只能在变量声明中包含初始化的时候使用(编译器可以推断出类型)</li></ul></li><li>引用参数 <strong>ref</strong>，输出参数 <strong>out</strong></li><li>属性：一般用来控制外部访问 private 字段，通过get和set的访问器来控制</li><li>get和set的访问级别可以不同，例如get为public，set为private，就可以设置为外部可读取但不可修改</li><li>构造函数可以被重载，从而可以创建不一样的实例</li><li><strong>readonly</strong> 与 const 类似，const必须在字段的声明语句中初始化，readonly可以在构造函数中再初始化</li></ul></blockquote><h3 id="继承、多态"><a href="#继承、多态" class="headerlink" title="继承、多态"></a>继承、多态</h3><blockquote><ul><li>派生类可以使用 new 关键词屏蔽基类的成员、基类可以通过 base 关键词访问被屏蔽的基类成员</li><li>可以通过virtual和override覆写基类的成员</li><li>abstract关键词修饰抽象类和抽象方法<ul><li>抽象类不能被实例化</li><li>抽象类必须被继承</li><li>抽象方法必须在派生类中实现</li><li>数据成员不可以声明为abstract</li></ul></li><li>密封类不可被继承，以 sealed 关键词修饰</li><li>静态类所有成员都是静态的，用于存放不受实例影响的数据和函数<ul><li>静态类使用static标记</li><li>可以有静态构造函数，但不能实例化</li><li>不可继承</li></ul></li></ul></blockquote><h3 id="表达式和运算符"><a href="#表达式和运算符" class="headerlink" title="表达式和运算符"></a>表达式和运算符</h3><blockquote><ul><li>字符串前加 @ ，不解析转义字符</li><li>赋值运算符、比较运算符、逻辑运算符、位运算符</li></ul></blockquote><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><blockquote><ul><li>结构声明时不允许初始化字段</li><li>结构不能被继承</li></ul></blockquote><h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><blockquote><ul><li>类似cpp函数指针，可以动态选择要运行的函数。</li><li>对C#委托<a href="https://blog.csdn.net/nicolas_li/article/details/8455754" target="_blank" rel="noopener">较好的解释</a></li><li><a href="https://www.w3cschool.cn/csharp/csharp-lambda-expressions.html" target="_blank" rel="noopener">C#中Lambda表达式</a></li></ul></blockquote><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><blockquote><ul><li>类似于委托，事件被触发时执行委托的函数列表</li><li>使用标准事件 Eventhandler 处理委托，需要两个参数EventHandler(<strong>object sender,EventArgs e</strong>)</li><li>拓展EventArgs来向事件的委托函数传递参数</li><li>发布者在适当处使用事件，订阅者在代码中声明事件处理方法，并在需要获得通知的地方订阅事件。</li></ul></blockquote><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><blockquote><ul><li>可以实现原生接口来使自己的类拥有原生的功能，例如sort</li><li>接口的声明不能有数据成员和静态成员，只能声明<strong>方法、属性、事件、索引器</strong></li><li>一个类可以继承并实现多个接口</li><li>接口可以继承接口</li></ul></blockquote><h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><blockquote><ul><li>可以使用 <strong>checked</strong> 和 <strong>unchecked</strong> 语句来检测转换溢出</li><li>装箱&amp;拆箱<ul><li>装箱：值类型转换为引用类型</li><li>拆箱：引用类型转换为值类型（试图转换为非原始类型会报错）</li></ul></li><li>使用 <strong>is</strong> 运算符检测转换是否可行（只可用于引用转换、装箱/拆箱转换）</li><li>自定义转换，即自定义的类或结构与其他类型之间的转换，需使用 <strong>implicit</strong></li><li><strong>as</strong> 运算符是作用类似强制转换，返回引用类型（只可用于引用转换和装箱转换）</li></ul></blockquote><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><blockquote><ul><li>泛型是类的模板，对参数类型宽容，具体使用时确定参数类型</li><li>泛型中的类型参数，可以使用 <strong>where</strong> 子句进行约束，从而确定可接受的参数类型,约束类型有：<ul><li>类名：约束为该类及其子类</li><li>class: 约束为任何引用类型，例如类，数组，委托，接口</li><li>struct: 约束为值类型</li><li>接口名：约束为这个接口及其实现类</li><li>new(): 又名 <strong>构造函数约束</strong>，约束为带有无参公共构造函数的类型</li></ul></li><li>约束顺序为：主约束(类名，class，struct)、接口约束、new()</li><li>可空类型，通过 <strong>?</strong> 运算符将值类型装箱为可空类型</li><li>处理可空变量的空值，通过 <strong>??</strong> 运算符将可能为空值的可空变量赋初值</li><li>对于可能返回空值的方法，可以使用 <strong>?.</strong> 运算符将该方法的返回值装箱为可空类型</li><li></li></ul></blockquote><h3 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h3><blockquote><ul><li>由 <strong>async/await</strong> 关键词修饰</li><li>async修饰方法名，await修饰方法中需要异步执行的任务</li><li>需要得到异步方法的返回值，使用 <strong>Task &lt; T &gt;</strong>，仅需要检查异步方法状态则使用 <strong>Task</strong>,仅执行异步代码则使用 <strong>void</strong></li><li><strong>Task &lt; T &gt;</strong> 返回的是类型为 <strong>T</strong> 的值</li><li>await后的异步任务需要返回<strong>awaitable</strong>类型，一般使用Task.Run(Func<treturn> func),Task.Run的参数是一个委托</treturn></li><li>Task.Delay() 延迟异步方法,实现GUI编程中的异步问题</li><li><a href="https://stackoverflow.com/questions/22645024/when-would-i-use-task-yield" target="_blank" rel="noopener">Task.Yield()</a></li><li>异步编程模式<ul><li>等待-直到结束模式:开始异步-&gt;完成其他简单处理-&gt;停止等待异步结束</li><li>轮询模式：开始异步-&gt;查询异步是否完成，未完成则进行其他处理-&gt;异步完成</li><li>回调模式：开始异步-&gt;初始线程继续处理-&gt;异步方法结束，自行调用结果处理函数</li><li>定时重复运行异步方法，Timer类</li></ul></li></ul></blockquote><h3 id="CLI-amp-amp-GC"><a href="#CLI-amp-amp-GC" class="headerlink" title="CLI &amp;&amp; GC"></a>CLI &amp;&amp; GC</h3><blockquote><ul><li>CLI：公共语言基础结构</li><li>CIL: 公共中间语言</li><li>VES: 运行时（虚拟执行系统）</li><li>C#代码—&gt;(C#编译器)—&gt;CIL—&gt;(JIT)—&gt;机器码</li></ul></blockquote><blockquote><p>以后<br>再<br>更新</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术&amp;学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
