<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SqlServer查看数据库连接情况</title>
      <link href="/2019/10/31/SqlServer%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%83%85%E5%86%B5/"/>
      <url>/2019/10/31/SqlServer%E6%9F%A5%E7%9C%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%83%85%E5%86%B5/</url>
      
        <content type="html"><![CDATA[<blockquote><ul><li>使用Sqlserver作为数据库时,如果需要查看某个数据库当前的连接情况，可以使用一下sql语句：</li></ul></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> </span><br><span class="line">[<span class="keyword">Master</span>].[dbo].[SYSPROCESSES] <span class="keyword">WHERE</span> [DBID] </span><br><span class="line"><span class="keyword">IN</span> </span><br><span class="line">(</span><br><span class="line">  <span class="keyword">SELECT</span> </span><br><span class="line">   [DBID]</span><br><span class="line">  <span class="keyword">FROM</span> </span><br><span class="line">   [<span class="keyword">Master</span>].[dbo].[SYSDATABASES] </span><br><span class="line">  <span class="keyword">WHERE</span> </span><br><span class="line">   <span class="keyword">NAME</span>=<span class="string">'你的数据库名称'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术&amp;学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#递归删除空文件夹</title>
      <link href="/2019/10/29/C-%E9%80%92%E5%BD%92%E5%88%A0%E9%99%A4%E7%A9%BA%E6%96%87%E4%BB%B6%E5%A4%B9/"/>
      <url>/2019/10/29/C-%E9%80%92%E5%BD%92%E5%88%A0%E9%99%A4%E7%A9%BA%E6%96%87%E4%BB%B6%E5%A4%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="C-递归删除某路径下空文件夹"><a href="#C-递归删除某路径下空文件夹" class="headerlink" title="C#递归删除某路径下空文件夹"></a>C#递归删除某路径下空文件夹</h1><blockquote><ul><li>C#递归删除某路径下的所有空文件夹</li></ul></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DeleteEmptyFolders</span>(<span class="params"><span class="keyword">string</span> location</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!Directory.Exists(location))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (Directory.GetDirectories(location).Length != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> subDirs = Directory.GetDirectories(location);</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> subDir <span class="keyword">in</span> subDirs)</span><br><span class="line">        &#123;</span><br><span class="line">            DeleteEmptyFolders(subDir);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (IsFolderEmpty(location) &amp;&amp; location != RootPath)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">$"Delete location: <span class="subst">&#123;location&#125;</span>"</span>);</span><br><span class="line">        Directory.Delete(location);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">IsFolderEmpty</span>(<span class="params"><span class="keyword">string</span> folderLocation</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Directory.Exists(folderLocation))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> filesAndFolders = Directory.GetFileSystemEntries(folderLocation);</span><br><span class="line">        <span class="keyword">return</span> filesAndFolders.Length == <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术&amp;学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Code segment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>wpf初探</title>
      <link href="/2019/09/18/wpf%E5%88%9D%E6%8E%A2/"/>
      <url>/2019/09/18/wpf%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="wpf初探"><a href="#wpf初探" class="headerlink" title="wpf初探"></a>wpf初探</h1><hr><h1 id="Binding"><a href="#Binding" class="headerlink" title="Binding"></a>Binding</h1><blockquote><ul><li>自定义的类想要实现binding的功能，需要实现 <strong>INotifyPropertyChanged</strong> 接口</li><li>数据源：只要是一个对象，并且通过属性( Property )公开自己的数据，就可以作为数据源</li><li>binding数据源与控件 <code>this.textboxName.SetBinding(TextBox.TextProperty,new Binding(&quot;Name&quot;){Source = stu})</code></li><li>除了在C#代码中Binding，还可以直接在XAML代码中Binding其他控件的属性。</li><li>通常Binding数据的方法有：<ul><li>普通CLR类型的单个对象作为Source，包括.NET Framework 自带类型的对象和用具自定义的对象</li><li>普通CLR集合类型对象作为Source，包括数组，List&lt; T &gt;,  ObservableCollection&lt; T &gt;</li><li>将 ADO.NET 数据对象指定为Source， 包括 DataTable 和 DataView等</li><li>使用 XmlDataProvider 把 xml 数据指定为Source</li><li>将依赖（Dependency Object）指定为Source</li><li>将容器的 DataContext 指定为 Source</li><li>通过ElementName 指定 Source</li><li>通过 Binding的 RelativeSource 属性相对地指定 Source</li><li>将 ObjectDataProvider 对象指定为 Source</li><li>将Linq检索得到的数据对象作为 Source</li></ul></li><li>容器的 DataContext 属性是会被子元素继承的属性。</li></ul></blockquote><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><blockquote><ul><li>依赖属性<ul><li>自己没有值，但是能通过使用binding从数据源获取值得属性</li><li>拥有依赖属性的对象称为依赖对象</li><li>wpf所有UI控件都是依赖对象</li></ul></li><li>在依赖对象中声明依赖属性需要使用 <code>public static readonly</code></li><li>依赖属性已经实现了<code>INotifyPropertyChanged</code>接口</li><li>附加属性<ul><li>附加属性的本质是依赖属性。</li><li>将属性与宿主解耦，让数据类型的设计更加灵活。</li></ul></li><li>??</li></ul></blockquote><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><blockquote><ul><li>CLR事件模型中，分为：<ul><li>事件拥有者</li><li>事件</li><li>事件响应者</li><li>事件处理者</li><li>订阅关系</li></ul></li><li>CLR事件模型的弊端：<ul><li>每队消息是“发送–&gt;相应”关系，必须建立显示的点对点订阅关系。</li><li>事件的宿主必须能够直接访问事件的响应者，不然无法建立订阅关系。</li></ul></li><li>WPF路由事件机制：<ul><li>事件拥有者和事件响应者没有直接的订阅关系</li><li>事件拥有者只负责激发事件，将事件在visual tree中传播</li><li>事件响应者有事件侦听器，当事件传递到该节点时，其事件处理器就会被调用，并决定是否继续传播事件（使用<code>RoutedEventArgs.Handled</code>标记）</li></ul></li><li>可以在cs代码中为控件绑定事件侦听器，也可以在XAML中直接在控件商绑定事件侦听器</li><li>路由事件有三种路由策略：<ul><li>Bubble,冒泡式：路由事件由事件的激发者出发向它的上级容器一层一层路由，直至最外层容器。</li><li>Tunnel，隧道式：由Visual Tree的树根向事件激发控件路由。</li><li>Direct，直达式：模仿CLR直接事件，直接将事件消息送达事件处理器。</li></ul></li><li>附加事件：在非UIElement派生类中注册的路由事件（<code>本质上只算是路由事件的一种用法而非一种新概念</code>）<ul><li>无法自己激发路由事件也无法侦听路由事件</li><li>附加事件路由第一站是激发它的元素</li><li>附加事件一般定义在Binding、Mouse、Keyboard这种全局Helper类中。</li></ul></li></ul></blockquote><h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><blockquote><ul><li>命令与事件的区别：<ul><li>命令可以约束消息处理代码</li><li>命令可以约束步骤逻辑</li></ul></li><li>命令系统的要素：<ul><li>命令：实现<code>ICommand</code>接口，使用最多的是<code>RoutedCommand</code></li><li>命令源：命令发送者，实现<code>ICommandSource</code>接口（只包含<code>Command</code>、<code>CommandParameter</code>、<code>CommandTarget</code>三个属性）</li><li>命令目标：实现<code>IInputElement</code>接口的类</li><li>命令关联：将外围逻辑与命令关联起来，比如<strong>执行前对命令是否可以执行进行判断，命令执行之后还有哪些后续工作等</strong></li></ul></li><li>使用自定义命令：<ul><li>声明并定义命令</li><li>将命令赋值给命令源（发送者）并<strong>指定快捷键（命令可以方便地指定快捷键）</strong></li><li>指定命令目标   <code>Tips:这一步有没有必要？因为在XAML中声明命令是不需要指定命令目标的</code></li><li>创建命令关联</li><li>将命令关联安置在外围控件上</li></ul></li><li><strong><code>CanExecute</code>事件的激发频率较高，为了尽量避免降低性能，在处理完后需要将<code>e.Handled</code>设置为<code>true</code></strong></li><li><strong>命令关联（CommandBinding</strong>一定要绑定在命令目标的外围控件上，不然无法捕获到<code>CanExecute</code>和<code>Executed</code>等路由事件  </li><li>常用命令库：<ul><li><code>ApplicationCommands</code></li><li><code>ComponentCommands</code></li><li><code>NavigationCommands</code></li><li><code>MediacCommands</code></li><li><code>EditingCommands</code></li></ul></li></ul><ul><li>命令参数：给命令目标传递参数，可以使同一个命令实现不同的操作。</li><li></li></ul></blockquote><h1 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h1><blockquote><ul><li>每个WPF界面元素都有<code>Resources</code>属性，这个属性类型为<code>ResouresDictionary</code>，使用 <strong>键-值</strong> 对的形式存储资源</li><li>静态资源与动态资源<ul><li>静态资源（<code>Static</code>）在程序载入内存时对资源一次性引用，之后就不再访问这个资源。</li><li>动态资源（<code>Dynamic</code>）在程序运行过程中仍然会访问这个资源，在程序运行过程中还有可能修改的资源应该使用<code>DynamciResource</code></li></ul></li><li>在<strong>资源词典</strong>里的资源称为“WPF资源”或者“对象资源”，应用程序内嵌的资源称为“程序集资源”或“二进制资源”</li><li>向WPF中添加二进制资源：<ul><li>如果添加的是字符串而非文件，则可以使用<code>Properties</code>名称空间中的<code>Resources.resx</code>资源文件。该文件也用<strong>键-值</strong>对储存数据。</li><li><strong>为了让XAML编译器能够访问<code>Resources</code>类，一定要把<code>Resources.resx</code>的访问级别由Internal改为Public</strong></li></ul></li><li>使用<code>Resources.resx</code>最大的好处是便于国际化，修改界面中的值直接修改资源即可。</li></ul></blockquote><h1 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h1><blockquote><ul><li>WPF中控件分为两大类：<ul><li><code>ControlTemplate</code>是算法内容的表现形式，决定了控件的外观，是控件的外衣</li><li><code>DataTemplate</code>是数据内容的表现形式，决定数据的显示样式，是数据的外衣</li></ul></li><li><code>DataTemplate</code>完成了数据驱动界面，常用于三处：<ul><li>ContentControl的ContentTemplate属性，相当于给ContentControl的内容穿外衣。</li><li>ItemsControl的ItemTemplate属性，相当于给ItemControl的数据条目穿衣。</li><li>GridViewColumn的CellTemplate属性，相当于给GridViewColumn单元格里的数据穿衣服。</li></ul></li><li><code>ControlTemplate</code>主要用于两处：<ul><li>更换ControlTemplate改变控件外观，使之具有更优的用户使用体验及外观。</li><li>借助ControlTemplate，程序员与设计师并行工作，先使用标准控件编程，设计完成后只需把新的ControlTemplate应用到程序中即可。</li></ul></li></ul></blockquote><h1 id="XAML"><a href="#XAML" class="headerlink" title="XAML"></a>XAML</h1><blockquote><ul><li><code>x:Name</code>实例化控件对象的引用变量的名称，方便查找相应控件</li><li><code>x:Key</code>为资源添加用于检索的索引。形成<code>Key-Value</code>键值对。</li><li>LogicalTree：描述了界面的整体框架；WPF大部分特性（属性值继承，事件路由以及样式）都是通过逻辑树进行工作的。</li><li>VisualTree：描述了界面的所有细节；使用样式可以改变视觉树上的元素，可以使用Style.TargetType属性来选择希望修改的特定元素，甚至当空间属性发生变化时，通过触发器自动完成修改。可以为控件创建新的模板。</li></ul></blockquote><h1 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h1><blockquote><ul><li>Grid：网格布局，可以自定义行与列的数量，行高，列宽开调整控件布局。类似以Html中的Table，适用于：<ul><li>UI布局的大框架设计</li><li>大量UI元素需要成行或者成列对齐</li><li>UI整体尺寸改变时，元素需要保持固有的高度和宽度比例</li><li>UI后期可能有焦大的变更或拓展</li></ul></li><li>StackPanel：栈式面板。可将包含的元素在竖直或者水平方向上排成一条直线，移除一个元素后，后排的元素会自动向前移动填补空缺。适用于：<ul><li>同类元素需要紧凑排列</li><li>移除其中的元素后能够自动补缺的布局或者动画</li></ul></li><li>Canvas：画布。内部元素可以使用以像素为单位的绝对坐标（<code>Canvas.X</code>和<code>Canvas.Y</code>）进行定位。适用于：<ul><li>一经设计基本上不会再有改动的小型布局（如：图标）</li><li>艺术性比较强的布局</li><li>需要大量使用横纵坐标进行绝对定位的布局。</li><li>依赖于横纵坐标的动画</li></ul></li><li>DockPanel：泊靠式面板。元素内部可以选择泊靠方向。<ul><li>内部元素根据<code>DockPanel.Dock</code>属性规定的方向泊靠。</li><li><code>LastChildFill</code>属性，默认为True，此时DockPanel内最后一个元素会将内部所有剩余空间充满。</li></ul></li><li>WrapPanel：自动折行面板。内部元素在排满一行后能自动折行，类似Html中的流式布局。</li></ul></blockquote><h1 id="异步修改UI"><a href="#异步修改UI" class="headerlink" title="异步修改UI"></a>异步修改UI</h1><blockquote><ul><li>BackgroundWorker：可以直接使用控件，每一步修改可以直接应用于控件</li><li>Dispatcher：不可以直接使用控件，每一步修改都需要向Dispatcher队列注册。</li></ul></blockquote><h1 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h1><blockquote><ul><li>MVVM = Model-View-ViewModel</li><li>Model层负责定义数据，获取数据</li><li>ViewModel层负责逻辑处理，处理Model层的数据，用于View层的数据绑定。</li><li>View层，即XAML代码，负责UI，与ViewModel层绑定。</li><li>从而解耦UI与逻辑，消灭XAML的后台代码。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术&amp;学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#学习--进阶篇</title>
      <link href="/2019/09/18/C-%E5%AD%A6%E4%B9%A0-%E8%BF%9B%E9%98%B6%E7%AF%87/"/>
      <url>/2019/09/18/C-%E5%AD%A6%E4%B9%A0-%E8%BF%9B%E9%98%B6%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="C-学习–进阶篇"><a href="#C-学习–进阶篇" class="headerlink" title="C#学习–进阶篇"></a>C#学习–进阶篇</h1><hr><h1 id="Q1-为何区分值类型和引用类型"><a href="#Q1-为何区分值类型和引用类型" class="headerlink" title="Q1.为何区分值类型和引用类型"></a>Q1.为何区分值类型和引用类型</h1><h2 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h2><blockquote><ul><li>引用类型可以实现接口，值类型当中的结构体也可以实现接口；</li><li>引用类型和值类型都继承自System.Object类。</li></ul></blockquote><h2 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h2><blockquote><ul><li>引用类型可以派生出新的类型，而值类型不能；</li><li>引用类型可以包含null值，值类型不能（可空类型功能允许将 null 赋给值类型）；</li><li>引用类型变量的赋值只复制对对象的引用，而不复制对象本身。而将一个值类型变量赋给另一个值类型变量时，将复制包含的值</li></ul></blockquote><h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><blockquote><ul><li>数组的元素不管是引用类型还是值类型，都存储在托管堆上。</li><li>引用类型在栈中存储一个引用，其实际的存储位置位于托管堆。简称引用类型部署在托管推上。而值类型总是分配在它声明的地方：作为字段时，跟随其所属的变量（实 例）存储；作为局部变量时，存储在栈上。（栈的内存是自动释放的，堆内存是.NET中会由GC来自动释放）</li></ul></blockquote><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><blockquote><ul><li>值类型在内存管理方面具有更好的效率，并且不支持多态，适合用做存储数据的载体；</li><li>引用类型支持多态，适合用于定义应用程序的行为。</li></ul></blockquote><br><br><hr><h1 id="Q2-为何要装箱和拆箱"><a href="#Q2-为何要装箱和拆箱" class="headerlink" title="Q2.为何要装箱和拆箱"></a>Q2.为何要装箱和拆箱</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><blockquote><ul><li>装箱是将值类型转换为引用类型 ；拆箱是将引用类型转换为值类型。</li></ul></blockquote><h2 id="为何要装箱"><a href="#为何要装箱" class="headerlink" title="为何要装箱"></a>为何要装箱</h2><blockquote><ul><li>较为典型的场景是：某方法或者容器为了保证通用，将参数定为object，那么在值类型作为参数时就需要装箱</li></ul><hr><ul><li>道理很简单，按理说C#被设计成一种完全面向对象的语言。因此，包括数字、字符、日期、布尔值等等在内的一切，都是对象。似乎只需要一种方式来对待这些对象就可以了。<br><br>但是C#不是只停留在学院中和理想中，它必须为性能而妥协，我们知道，对于CPU来说，处理一个完整的对象，需要很多的指令，对于内存来说，又需要很多的内存。如果连整数都是对象，那么性能自然很低。C#于是使用了一种机制，使得这些基本类型在一般的编程中被当作非对象的简单类型处理，在另一些场合，又允许它们被视作是一个对象。这种机制就是装箱和拆箱。<br><br>装箱后的对象看上去和一个对象一样，拥有方法，可以当作object处理，拆箱后的变量，看上去又如同C语言中的那些变量、结构体一样，可以直接参与运算和处理。<br><p align="right">—<a href="https://bbs.csdn.net/topics/390624164?page=1" target="_blank" rel="noopener">CSDN某帖子四楼</a></p></li></ul></blockquote><hr><h1 id="Q3-协变与逆变"><a href="#Q3-协变与逆变" class="headerlink" title="Q3.协变与逆变"></a>Q3.协变与逆变</h1><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><blockquote><p><em>查了半天，还是<a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98" target="_blank" rel="noopener">wiki</a>讲的最明白，其他的网站都描述的太抽象了。</em>  </p><ul><li>协变与逆变是一种术语，描述泛型的一个特性，这个特性具体解释如下：</li><li>在一门程序设计语言的类型系统中，一个类型规则或者类型构造器是：<ul><li>协变（covariant），如果它保持了子类型序关系≦。该序关系是：子类型≦基类型。</li><li>逆变（contravariant），如果它逆转了子类型序关系。</li><li>不变（invariant），如果上述两种均不适用。    </li></ul></li></ul></blockquote><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><blockquote><ul><li>这样的定义有点抽象，举个栗子来描述一下定义：  </li><li>如果Cat是Animal的子类型，那么Cat类型的表达式可用于任何出现Animal类型表达式的地方。  </li><li>那么我们在这两个类上各构造一个数组，Cat[ ] 与 Animal[ ] (数组是一种泛型吧)<ul><li>如果Cat[ ] 也是Animal[ ] 的子类，那么数组类型构造器就是 <strong>协变</strong>，因为通过这个构造器构造的对象保持了其构造类型的父子关系。</li><li>如果Animal[ ] 变为了Cat[ ] 的子类，那么该类型构造器就是 <strong>逆变</strong>，因为通过这个构造器构造的对象逆变了其构造类型的父子关系。</li><li>以上两者均不是，则该构造器是 <strong>不变</strong> 的。</li></ul></li><li>一般的函数类型，<strong>对于输入参数是逆变的，对于输出参数是协变的。</strong><ul><li>例如： 函数类型Cat-&gt;Cat可安全用于期望Cat-&gt;Animal的地方；类似地，函数类型Animal-&gt;Animal可用于期望Cat-&gt;Animal的地方——典型地，在 Animal a=Fn(Cat(…)) 这种语境下进行调用，由于 Cat 是 Animal 的子类所以即使 Fn 接受一只 Animal 也同样是安全的。一般规则是：<br>S1 → S2 ≦ T1 → T2 当T1 ≦ S1且S2 ≦ T2.</li></ul></li><li>在 C# 中，每个泛型接口的类型参数都可被标注为协变（out）、逆变（in）或不变（不标注）。例如，可以定义一个接口 IEnumerator<t> 作为只读的迭代器，并声明它在其类型参数上具有协变性,代码如下：</t></li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> interface IEnumerator&lt;out T&gt;</span><br><span class="line"> &#123;</span><br><span class="line">    T Current</span><br><span class="line">    &#123;</span><br><span class="line">        get;</span><br><span class="line">    &#125;</span><br><span class="line">    bool MoveNext();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>通过这样声明，IEnumerator<t> 就会在其类型参数上具有协变性。例如，IEnumerator&lt; Cat &gt; 是 IEnumerator&lt; Animal &gt; 的子类型。</t></li><li>协/逆变合法性：<ul><li>非泛型类型（类、结构、枚举等）既协变合法、也逆变合法。</li><li>类型参数 T 如果没有标 in，那么是协变合法；如果没有标 out，那么是逆变合法。</li><li>如果类型 A 是协 / 逆变合法，那么相应的数组类型 A[ ] 是协 / 逆变合法（C# 的数组是协变的）</li><li>泛型类型 G&lt;A1, A2, …, An&gt; 是协 / 逆变合法，如果对于每个类型参数 Ai：<ul><li>Ai 是协 / 逆变合法，当且仅当 G 中的第 i 个参数被声明为协变</li><li>Ai 是逆 / 协变合法（反转），当且仅当 G 中的第 i 个参数被声明为逆变</li><li>Ai 既协变合法又逆变合法，当且仅当 G 中的第 i 个参数被声明为不变</li></ul></li></ul></li></ul></blockquote><hr><h1 id="Q4-C-中造成内存泄露的主要原因"><a href="#Q4-C-中造成内存泄露的主要原因" class="headerlink" title="Q4.C#中造成内存泄露的主要原因"></a>Q4.C#中造成内存泄露的主要原因</h1><h2 id="事件-大多数内存泄露的原因"><a href="#事件-大多数内存泄露的原因" class="headerlink" title="事件(大多数内存泄露的原因)"></a>事件(大多数内存泄露的原因)</h2><blockquote><ul><li>C#的GC是使用标记清除算法来自动回收垃圾的。具体的流程是，从GCRoot开始遍历托管堆内所有对象，将遍历到的对象标记为可达对象，在遍历完成后，回收所有的非可达对象。<ul><li>注册在事件中的订阅者们由于事件一直存在，所以这些订阅者都一直处于可达状态,注册在事件上的对象一直存在于内存中，造成内存泄露。</li></ul></li></ul></blockquote><h2 id="非托管对象"><a href="#非托管对象" class="headerlink" title="非托管对象"></a>非托管对象</h2><blockquote><ul><li>非托管对象必须手动释放，必须通过Dispose释放非托管资源。可以使用 <strong>using</strong> 语句隐式调用Dispose,也可以使用Try/finally语句显式调用Dispose</li><li>创建非托管对象一定要注意命名规范，才能避免忘记释放该对象。</li><li>使用using语句处理非托管资源示例：</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.IO;</span><br><span class="line">using System.Text.RegularExpressions;</span><br><span class="line"></span><br><span class="line">public class WordCount</span><br><span class="line">&#123;</span><br><span class="line">   private String filename = String.Empty;</span><br><span class="line">   private int nWords = 0;</span><br><span class="line">   private String pattern = @&quot;\b\w+\b&quot;; </span><br><span class="line"></span><br><span class="line">   public WordCount(string filename)</span><br><span class="line">   &#123;</span><br><span class="line">      if (! File.Exists(filename))</span><br><span class="line">         throw new FileNotFoundException(&quot;The file does not exist.&quot;);</span><br><span class="line">      </span><br><span class="line">      this.filename = filename;</span><br><span class="line">      string txt = String.Empty;</span><br><span class="line">      using (StreamReader sr = new StreamReader(filename)) &#123;</span><br><span class="line">         txt = sr.ReadToEnd();</span><br><span class="line">      &#125;</span><br><span class="line">      nWords = Regex.Matches(txt, pattern).Count;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public string FullName</span><br><span class="line">   &#123; get &#123; return filename; &#125; &#125;</span><br><span class="line">   </span><br><span class="line">   public string Name</span><br><span class="line">   &#123; get &#123; return Path.GetFileName(filename); &#125; &#125;</span><br><span class="line">   </span><br><span class="line">   public int Count </span><br><span class="line">   &#123; get &#123; return nWords; &#125; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集合-静态对象"><a href="#集合-静态对象" class="headerlink" title="集合/静态对象"></a>集合/静态对象</h2><blockquote><ul><li>集合需要及时clear，尤其是将一些方法中的临时变量添加到集合中后，会导致集合膨胀，使其内存泄露。</li><li>静态字段在整个程序运行期间都不会释放，所以尽量减少其可见域就减少了其内存泄露的可能性。</li><li>尽量不要声明静态的集合，静态的集合很容易造成内存泄露。</li></ul></blockquote><hr><h1 id="Q5-Task-与-Parallel"><a href="#Q5-Task-与-Parallel" class="headerlink" title="Q5.Task 与 Parallel"></a>Q5.Task 与 Parallel</h1><p><strong>Updating</strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术&amp;学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C#学习--初级篇</title>
      <link href="/2019/09/18/C-%E5%AD%A6%E4%B9%A0-%E5%88%9D%E7%BA%A7%E7%AF%87/"/>
      <url>/2019/09/18/C-%E5%AD%A6%E4%B9%A0-%E5%88%9D%E7%BA%A7%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h1 id="C-学习–初级学习"><a href="#C-学习–初级学习" class="headerlink" title="C#学习–初级学习"></a>C#学习–初级学习</h1><hr><h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><blockquote><ul><li>参数使用驼峰命名法</li><li>其余命名均使用帕斯卡命名法</li><li>属性和关联字段命名：关联字段使用驼峰命名法，属性使用帕斯卡命名法</li></ul></blockquote><h3 id="类型、存储、变量"><a href="#类型、存储、变量" class="headerlink" title="类型、存储、变量"></a>类型、存储、变量</h3><blockquote><ul><li>类型是模板，需要实例化才能使用</li><li>dynamic 动态类型</li><li>C#中数值类型不具有bool意义</li><li>除了16种预定义类型，还有6种可以自定义的类型<ul><li>类 (class)</li><li>结构 (struct)</li><li>数组 (array)</li><li>枚举 (enum)</li><li>委托 (delegate)</li><li>接口 (interface)</li></ul></li><li>引用类型的所有数据成员都在堆里</li><li>匿名类型(var)需要属性名称、数据类型、属性顺序都完全相同才能“类型兼容”</li><li>匿名类型(var)是只读的，一旦实例化就不可变</li></ul></blockquote><h3 id="类、方法"><a href="#类、方法" class="headerlink" title="类、方法"></a>类、方法</h3><blockquote><ul><li>访问控制有5种<ul><li>private:仅该类内部可访问</li><li>public：任何类均可访问</li><li>protected：所有继承该类的类可访问</li><li>internal：仅该程序集 <strong>(.dll &amp;&amp; .exe)</strong> 内所有类可访问</li><li>protected internal：继承该类的类或该程序集内的类可访问</li></ul></li><li>类的成员默认为private，也可以显式声明，public必须显式声明</li><li>var关键字<ul><li>只能在方法里使用，不能用于字段</li><li>只能在变量声明中包含初始化的时候使用(编译器可以推断出类型)</li></ul></li><li>引用参数 <strong>ref</strong>，输出参数 <strong>out</strong></li><li>属性：一般用来控制外部访问 private 字段，通过get和set的访问器来控制</li><li>get和set的访问级别可以不同，例如get为public，set为private，就可以设置为外部可读取但不可修改</li><li>构造函数可以被重载，从而可以创建不一样的实例</li><li><strong>readonly</strong> 与 const 类似，const必须在字段的声明语句中初始化，readonly可以在构造函数中再初始化</li></ul></blockquote><h3 id="继承、多态"><a href="#继承、多态" class="headerlink" title="继承、多态"></a>继承、多态</h3><blockquote><ul><li>派生类可以使用 new 关键词屏蔽基类的成员、基类可以通过 base 关键词访问被屏蔽的基类成员</li><li>可以通过virtual和override覆写基类的成员</li><li>abstract关键词修饰抽象类和抽象方法<ul><li>抽象类不能被实例化</li><li>抽象类必须被继承</li><li>抽象方法必须在派生类中实现</li><li>数据成员不可以声明为abstract</li></ul></li><li>密封类不可被继承，以 sealed 关键词修饰</li><li>静态类所有成员都是静态的，用于存放不受实例影响的数据和函数<ul><li>静态类使用static标记</li><li>可以有静态构造函数，但不能实例化</li><li>不可继承</li></ul></li></ul></blockquote><h3 id="表达式和运算符"><a href="#表达式和运算符" class="headerlink" title="表达式和运算符"></a>表达式和运算符</h3><blockquote><ul><li>字符串前加 @ ，不解析转义字符</li><li>赋值运算符、比较运算符、逻辑运算符、位运算符</li></ul></blockquote><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><blockquote><ul><li>结构声明时不允许初始化字段</li><li>结构不能被继承</li></ul></blockquote><h3 id="委托"><a href="#委托" class="headerlink" title="委托"></a>委托</h3><blockquote><ul><li>类似cpp函数指针，可以动态选择要运行的函数。</li><li>对C#委托<a href="https://blog.csdn.net/nicolas_li/article/details/8455754" target="_blank" rel="noopener">较好的解释</a></li><li><a href="https://www.w3cschool.cn/csharp/csharp-lambda-expressions.html" target="_blank" rel="noopener">C#中Lambda表达式</a></li></ul></blockquote><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><blockquote><ul><li>类似于委托，事件被触发时执行委托的函数列表</li><li>使用标准事件 Eventhandler 处理委托，需要两个参数EventHandler(<strong>object sender,EventArgs e</strong>)</li><li>拓展EventArgs来向事件的委托函数传递参数</li><li>发布者在适当处使用事件，订阅者在代码中声明事件处理方法，并在需要获得通知的地方订阅事件。</li></ul></blockquote><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><blockquote><ul><li>可以实现原生接口来使自己的类拥有原生的功能，例如sort</li><li>接口的声明不能有数据成员和静态成员，只能声明<strong>方法、属性、事件、索引器</strong></li><li>一个类可以继承并实现多个接口</li><li>接口可以继承接口</li></ul></blockquote><h3 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h3><blockquote><ul><li>可以使用 <strong>checked</strong> 和 <strong>unchecked</strong> 语句来检测转换溢出</li><li>装箱&amp;拆箱<ul><li>装箱：值类型转换为引用类型</li><li>拆箱：引用类型转换为值类型（试图转换为非原始类型会报错）</li></ul></li><li>使用 <strong>is</strong> 运算符检测转换是否可行（只可用于引用转换、装箱/拆箱转换）</li><li>自定义转换，即自定义的类或结构与其他类型之间的转换，需使用 <strong>implicit</strong></li><li><strong>as</strong> 运算符是作用类似强制转换，返回引用类型（只可用于引用转换和装箱转换）</li></ul></blockquote><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><blockquote><ul><li>泛型是类的模板，对参数类型宽容，具体使用时确定参数类型</li><li>泛型中的类型参数，可以使用 <strong>where</strong> 子句进行约束，从而确定可接受的参数类型,约束类型有：<ul><li>类名：约束为该类及其子类</li><li>class: 约束为任何引用类型，例如类，数组，委托，接口</li><li>struct: 约束为值类型</li><li>接口名：约束为这个接口及其实现类</li><li>new(): 又名 <strong>构造函数约束</strong>，约束为带有无参公共构造函数的类型</li></ul></li><li>约束顺序为：主约束(类名，class，struct)、接口约束、new()</li><li>可空类型，通过 <strong>?</strong> 运算符将值类型装箱为可空类型</li><li>处理可空变量的空值，通过 <strong>??</strong> 运算符将可能为空值的可空变量赋初值</li><li>对于可能返回空值的方法，可以使用 <strong>?.</strong> 运算符将该方法的返回值装箱为可空类型</li><li></li></ul></blockquote><h3 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h3><blockquote><ul><li>由 <strong>async/await</strong> 关键词修饰</li><li>async修饰方法名，await修饰方法中需要异步执行的任务</li><li>需要得到异步方法的返回值，使用 <strong>Task &lt; T &gt;</strong>，仅需要检查异步方法状态则使用 <strong>Task</strong>,仅执行异步代码则使用 <strong>void</strong></li><li><strong>Task &lt; T &gt;</strong> 返回的是类型为 <strong>T</strong> 的值</li><li>await后的异步任务需要返回<strong>awaitable</strong>类型，一般使用Task.Run(Func<treturn> func),Task.Run的参数是一个委托</treturn></li><li>Task.Delay() 延迟异步方法,实现GUI编程中的异步问题</li><li><a href="https://stackoverflow.com/questions/22645024/when-would-i-use-task-yield" target="_blank" rel="noopener">Task.Yield()</a></li><li>异步编程模式<ul><li>等待-直到结束模式:开始异步-&gt;完成其他简单处理-&gt;停止等待异步结束</li><li>轮询模式：开始异步-&gt;查询异步是否完成，未完成则进行其他处理-&gt;异步完成</li><li>回调模式：开始异步-&gt;初始线程继续处理-&gt;异步方法结束，自行调用结果处理函数</li><li>定时重复运行异步方法，Timer类</li></ul></li></ul></blockquote><h3 id="CLI-amp-amp-GC"><a href="#CLI-amp-amp-GC" class="headerlink" title="CLI &amp;&amp; GC"></a>CLI &amp;&amp; GC</h3><blockquote><ul><li>CLI：公共语言基础结构</li><li>CIL: 公共中间语言</li><li>VES: 运行时（虚拟执行系统）</li><li>C#代码—&gt;(C#编译器)—&gt;CIL—&gt;(JIT)—&gt;机器码</li></ul></blockquote><blockquote><p>以后<br>再<br>更新</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 技术&amp;学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
